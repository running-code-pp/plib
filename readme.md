# å¦‚ä½•è®¾è®¡ä¸€ä¸ªæ”¯æŒæŒä¹…åŒ–çš„åµŒå…¥å¼ KV å­˜å‚¨ç³»ç»Ÿ

> åŸºäº Desktop App Toolkit Cache ç³»ç»Ÿçš„è®¾è®¡åˆ†æä¸å®è·µæŒ‡å—

---

## ğŸ“‹ ç›®å½•

1. [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
2. [æ ¸å¿ƒè®¾è®¡åŸåˆ™](#æ ¸å¿ƒè®¾è®¡åŸåˆ™)
3. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
4. [å…³é”®ç»„ä»¶è¯¦è§£](#å…³é”®ç»„ä»¶è¯¦è§£)
5. [æ•°æ®ç»“æ„è®¾è®¡](#æ•°æ®ç»“æ„è®¾è®¡)
6. [æŒä¹…åŒ–ç­–ç•¥](#æŒä¹…åŒ–ç­–ç•¥)
7. [æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯](#æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯)
8. [å¯é æ€§ä¿è¯](#å¯é æ€§ä¿è¯)
9. [å®ç°æ­¥éª¤](#å®ç°æ­¥éª¤)
10. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## ç³»ç»Ÿæ¦‚è¿°

### ä»€ä¹ˆæ˜¯åµŒå…¥å¼ KV å­˜å‚¨

åµŒå…¥å¼ KVï¼ˆKey-Valueï¼‰å­˜å‚¨æ˜¯ä¸€ä¸ªç›´æ¥é›†æˆåˆ°åº”ç”¨ç¨‹åºä¸­çš„æŒä¹…åŒ–æ•°æ®åº“ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **æ— éœ€ç‹¬ç«‹è¿›ç¨‹**ï¼šåº“çš„å½¢å¼é›†æˆï¼Œä¸éœ€è¦å•ç‹¬çš„æœåŠ¡å™¨
- **å•åº”ç”¨è®¿é—®**ï¼šä¸“ä¸ºå•ä¸€åº”ç”¨ç¨‹åºè®¾è®¡
- **è½»é‡çº§**ï¼šèµ„æºå ç”¨å°ï¼Œå¯åŠ¨å¿«é€Ÿ
- **æŒä¹…åŒ–**ï¼šæ•°æ®å†™å…¥ç£ç›˜ï¼Œç¨‹åºé‡å¯åå¯æ¢å¤

### é€‚ç”¨åœºæ™¯

**âœ… æ¨èåœºæ™¯**ï¼š
- **æ¡Œé¢åº”ç”¨çš„æœ¬åœ°ç¼“å­˜**ï¼ˆå›¾ç‰‡ã€æ–‡ä»¶ã€é…ç½®ç­‰ï¼‰
  - æ•°æ®é‡ï¼š10 ä¸‡ - 100 ä¸‡æ¡è®°å½•
  - å†…å­˜å ç”¨ï¼š< 100 MBï¼ˆç´¢å¼•ï¼‰
  - ç¤ºä¾‹ï¼šTelegramã€å¾®ä¿¡ã€æµè§ˆå™¨ç¼“å­˜
  
- **ç§»åŠ¨åº”ç”¨çš„ç¦»çº¿æ•°æ®å­˜å‚¨**
  - æ•°æ®é‡ï¼š< 10 ä¸‡æ¡è®°å½•
  - å†…å­˜å ç”¨ï¼š< 10 MBï¼ˆç´¢å¼•ï¼‰
  - ç¤ºä¾‹ï¼šèŠå¤©è®°å½•ã€èµ„æºç¼“å­˜
  
- **å°å‹æœåŠ¡çš„ä¼šè¯å­˜å‚¨**
  - æ•°æ®é‡ï¼š< 100 ä¸‡ä¼šè¯
  - å†…å­˜å ç”¨ï¼š< 100 MBï¼ˆç´¢å¼•ï¼‰
  
- **åµŒå…¥å¼è®¾å¤‡æ•°æ®å­˜å‚¨**ï¼ˆå†…å­˜å……è¶³æ—¶ï¼‰
  - æ•°æ®é‡ï¼š< 1 ä¸‡æ¡è®°å½•
  - å†…å­˜å ç”¨ï¼š< 1 MBï¼ˆç´¢å¼•ï¼‰

**âŒ ä¸é€‚åˆåœºæ™¯**ï¼š
- **å¤§æ•°æ®åœºæ™¯**ï¼ˆæ•°åäº¿æ¡è®°å½•ï¼‰â†’ ä½¿ç”¨ LevelDB/RocksDB
- **åˆ†å¸ƒå¼ç¼“å­˜**ï¼ˆè·¨æœºå™¨ï¼‰â†’ ä½¿ç”¨ Redis/Memcached
- **æå°å†…å­˜è®¾å¤‡**ï¼ˆ< 64MB RAMï¼‰â†’ ä½¿ç”¨çº¯ç£ç›˜ç´¢å¼•
- **æ— é™å¢é•¿æ•°æ®**ï¼ˆæ—¥å¿—ç³»ç»Ÿï¼‰â†’ éœ€è¦å½’æ¡£ç­–ç•¥

### å…³é”®ç‰¹æ€§

- **å…¨å†…å­˜ç´¢å¼• + ç£ç›˜æ•°æ®**ï¼šç´¢å¼•åœ¨å†…å­˜ï¼Œæ•°æ®åœ¨ç£ç›˜
- **é€‚ç”¨è§„æ¨¡**ï¼š10 ä¸‡ - 1000 ä¸‡æ¡è®°å½•ï¼ˆå†…å­˜å…è®¸çš„æƒ…å†µä¸‹ï¼‰
- **æŸ¥æ‰¾æ€§èƒ½**ï¼šO(1)ï¼Œå¾®ç§’çº§å“åº”
- **å¯åŠ¨æ—¶é—´**ï¼šç™¾ä¸‡çº§æ•°æ®çº¦ 1-2 ç§’ï¼ˆé€šè¿‡ binlog é‡æ”¾ï¼‰

---

## æ ¸å¿ƒè®¾è®¡åŸåˆ™

### 1. å´©æºƒä¸€è‡´æ€§ï¼ˆCrash Consistencyï¼‰

**é—®é¢˜**ï¼šç¨‹åºå´©æºƒæˆ–çªç„¶æ–­ç”µæ—¶å¦‚ä½•ä¿è¯æ•°æ®ä¸ä¸¢å¤±ã€ä¸æŸåï¼Ÿ

**è§£å†³æ–¹æ¡ˆï¼šWALï¼ˆWrite-Ahead Loggingï¼‰**

```
æ“ä½œæµç¨‹ï¼š
1. å…ˆå†™ binlogï¼ˆæ“ä½œæ—¥å¿—ï¼‰
2. å†™å…¥æˆåŠŸåæ‰§è¡Œå®é™…æ“ä½œ
3. å®šæœŸå‹ç¼© binlog

å´©æºƒæ¢å¤ï¼š
1. é‡å¯æ—¶è¯»å– binlog
2. é‡æ”¾æ‰€æœ‰æ“ä½œ
3. é‡å»ºå†…å­˜ç´¢å¼•
```

**å…³é”®ä»£ç ç»“æ„**ï¼š
```cpp
// æ‰€æœ‰ä¿®æ”¹æ“ä½œéƒ½å…ˆå†™ binlog
Error writeOperation() {
    // 1. å†™å…¥ binlog è®°å½•
    if (!writeToBinlog(operation)) {
        return Error::IO;
    }
    
    // 2. æ‰§è¡Œå®é™…æ“ä½œ
    executeOperation();
    
    // 3. æ›´æ–°å†…å­˜ç´¢å¼•
    updateIndex();
    
    return Error::NoError();
}
```

### 2. æ•°æ®å®Œæ•´æ€§ï¼ˆData Integrityï¼‰

**æ ¡éªŒå’Œæœºåˆ¶**ï¼š
- æ¯ä¸ªæ•°æ®å—éƒ½æœ‰ CRC32/xxHash æ ¡éªŒå’Œ
- è¯»å–æ—¶éªŒè¯ï¼ŒæŸåæ•°æ®æ‹’ç»è¿”å›
- å®šæœŸæ‰«ææ£€æŸ¥æ•°æ®å®Œæ•´æ€§

### 3. å†…å­˜ä¸ç£ç›˜åˆ†ç¦»

**è®¾è®¡æ¨¡å¼ï¼šç´¢å¼•åœ¨å†…å­˜ï¼Œæ•°æ®åœ¨ç£ç›˜**

```
æŸ¥è¯¢æµç¨‹ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  åº”ç”¨æŸ¥è¯¢     â”‚  get(Key)
â”‚  Key â†’ Value â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å†…å­˜å±‚ï¼šå¿«é€Ÿç´¢å¼•ï¼ˆHashMapï¼‰          â”‚
â”‚  Key â†’ Entry {                       â”‚
â”‚    place: ç£ç›˜åœ°å€                    â”‚  â† åªå­˜å…ƒæ•°æ®ï¼ˆ48Bï¼‰
â”‚    size: æ•°æ®å¤§å°                     â”‚
â”‚    checksum: æ ¡éªŒå’Œ                  â”‚
â”‚  }                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ æ‰¾åˆ°ç£ç›˜åœ°å€
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å…ƒæ•°æ®å±‚ï¼šBinlogï¼ˆæ“ä½œæ—¥å¿—ï¼‰          â”‚
â”‚  [Store][Store][Remove]...           â”‚  â† å´©æºƒæ¢å¤ç”¨
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æ•°æ®å±‚ï¼šå®é™…æ•°æ®æ–‡ä»¶                  â”‚
â”‚  0000.db: [Value1][Value2]...        â”‚  â† å­˜å®é™…æ•°æ®
â”‚  0001.db: [Value3][Value4]...        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ**

| æ–¹æ¡ˆ | ç´¢å¼• | æ•°æ® | å†…å­˜å ç”¨ | ä¼˜ç¼ºç‚¹ |
|------|------|------|---------|--------|
| **æœ¬ç³»ç»Ÿ** | å†…å­˜ | ç£ç›˜ | ä½ï¼ˆä»…ç´¢å¼•ï¼‰ | âœ… æ”¯æŒå¤§æ•°æ®é›†<br>âš ï¸ è¯»å–æœ‰ç£ç›˜å»¶è¿Ÿ |
| **çº¯å†…å­˜**ï¼ˆRedisï¼‰ | å†…å­˜ | å†…å­˜ | é«˜ï¼ˆå…¨éƒ¨ï¼‰ | âœ… æå¿«<br>âŒ å—å†…å­˜é™åˆ¶ |
| **çº¯ç£ç›˜**ï¼ˆSQLiteï¼‰ | ç£ç›˜ | ç£ç›˜ | æä½ | âœ… æ— å†…å­˜é™åˆ¶<br>âŒ æŸ¥æ‰¾æ…¢ |

**ç¤ºä¾‹**ï¼šå­˜å‚¨ 100 ä¸‡å¼ å›¾ç‰‡ç¼“å­˜
- æ¯å¼ å›¾ç‰‡å¹³å‡ 500KB
- æ€»æ•°æ®ï¼š500 GB

```
çº¯å†…å­˜æ–¹æ¡ˆï¼ˆRedisï¼‰ï¼š
  ç´¢å¼•ï¼š50 MB
  æ•°æ®ï¼š500 GB
  æ€»å†…å­˜ï¼š500.05 GB  âŒ ä¸å¯è¡Œï¼

æœ¬ç³»ç»Ÿæ–¹æ¡ˆï¼š
  ç´¢å¼•ï¼š50 MBï¼ˆå†…å­˜ï¼‰
  æ•°æ®ï¼š500 GBï¼ˆç£ç›˜ï¼‰
  æ€»å†…å­˜ï¼š50 MB  âœ… å®Œå…¨å¯è¡Œï¼
  
  è¯»å–æ€§èƒ½ï¼š
  - æŸ¥æ‰¾é”®å­˜åœ¨æ€§ï¼š< 1Î¼sï¼ˆå†…å­˜ç´¢å¼•ï¼‰
  - è¯»å–æ•°æ®ï¼š1-10msï¼ˆSSDï¼‰æˆ– 10-50msï¼ˆHDDï¼‰
```

### 4. çº¿ç¨‹å®‰å…¨

**å•çº¿ç¨‹æ¨¡å‹**ï¼ˆæ¨èï¼‰ï¼š
- æ‰€æœ‰æ“ä½œåœ¨ä¸“ç”¨çº¿ç¨‹æ‰§è¡Œ
- é¿å…å¤æ‚çš„é”æœºåˆ¶
- ä½¿ç”¨æ¶ˆæ¯é˜Ÿåˆ—é€šä¿¡

```cpp
// ä½¿ç”¨ crl::object_on_queue å®ç°
class Database {
    crl::object_on_queue<DatabaseObject> _impl;
    
    void put(Key key, Value value, Callback done) {
        _impl.with([=](DatabaseObject &db) {
            db.putInternal(key, value);
            done(Error::NoError());
        });
    }
};
```

---

## æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              åº”ç”¨ç¨‹åº API å±‚                      â”‚
â”‚  (Database - çº¿ç¨‹å®‰å…¨åŒ…è£…å™¨)                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           DatabaseObject (æ ¸å¿ƒå¼•æ“)              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚ å†…å­˜ç´¢å¼• Map â”‚  â”‚ Binlog æ—¥å¿—  â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚   Cleaner    â”‚  â”‚  Compactor   â”‚             â”‚
â”‚  â”‚  (æ¸…ç†å™¨)     â”‚  â”‚  (å‹ç¼©å™¨)     â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              åŠ å¯†æ–‡ä»¶ç³»ç»Ÿå±‚                        â”‚
â”‚         (EncryptedFile)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ“ä½œç³»ç»Ÿæ–‡ä»¶ç³»ç»Ÿ                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ç»„ä»¶èŒè´£

| ç»„ä»¶ | èŒè´£ | å…³é”®ç‰¹æ€§ |
|------|------|---------|
| **Database** | å…¬å…± APIï¼Œçº¿ç¨‹å®‰å…¨åŒ…è£… | å¼‚æ­¥å›è°ƒã€é˜Ÿåˆ—åŒ–æ“ä½œ |
| **DatabaseObject** | æ ¸å¿ƒå¼•æ“ï¼Œä¸šåŠ¡é€»è¾‘ | ç´¢å¼•ç®¡ç†ã€æ•°æ®è¯»å†™ |
| **BinlogReader/Writer** | æ—¥å¿—è¯»å†™ | å´©æºƒæ¢å¤ã€æ“ä½œé‡æ”¾ |
| **Cleaner** | ç©ºé—´å›æ”¶ | LRU æ¸…ç†ã€è¿‡æœŸæ•°æ®åˆ é™¤ |
| **Compactor** | æ—¥å¿—å‹ç¼© | ç¢ç‰‡æ•´ç†ã€ç©ºé—´ä¼˜åŒ– |
| **EncryptedFile** | åŠ å¯†æ–‡ä»¶ | AES åŠ å¯†ã€å¯†é’¥ç®¡ç† |

---

## å…³é”®ç»„ä»¶è¯¦è§£

### 1. é”®ï¼ˆKeyï¼‰è®¾è®¡

```cpp
struct Key {
    uint64 high = 0;  // é«˜ 64 ä½
    uint64 low = 0;   // ä½ 64 ä½
    
    // 128 ä½é”®ç©ºé—´ï¼š2^128 â‰ˆ 3.4 Ã— 10^38
};

// ä¸ºä»€ä¹ˆç”¨ 128 ä½ï¼Ÿ
// - é¿å…å“ˆå¸Œå†²çªï¼ˆç”Ÿæ—¥æ”»å‡»ï¼‰
// - æ”¯æŒ UUIDã€SHA1 æˆªæ–­ç­‰å¤šç§é”®ç”Ÿæˆæ–¹å¼
// - å¯å­˜å‚¨å¤åˆé”®ï¼ˆtype + idï¼‰
```

**é”®çš„ç”Ÿæˆç­–ç•¥**ï¼š
```cpp
// æ–¹æ¡ˆ1ï¼šæ–‡ä»¶è·¯å¾„å“ˆå¸Œ
Key keyFromPath(const QString &path) {
    auto hash = XXH128(path.toUtf8());
    return Key{hash.high64, hash.low64};
}

// æ–¹æ¡ˆ2ï¼šå¤åˆé”®ï¼ˆå°† type å’Œ id ç¼–ç åˆ° 128 ä½é”®ä¸­ï¼‰
Key keyFromTypeAndId(uint32 type, uint64 id) {
    // å¸ƒå±€ï¼š[type(32ä½) | idé«˜32ä½(32ä½)] [idä½32ä½(64ä½)]
    return Key{
        (uint64(type) << 32) | (id >> 32),  // high: type + idçš„é«˜32ä½
        id & 0xFFFFFFFF                     // low: idçš„ä½32ä½ï¼ˆæ˜¾å¼æå–ï¼‰
    };
}

// è§£ç ç¤ºä¾‹
std::pair<uint32, uint64> decodeKey(const Key &key) {
    uint32 type = key.high >> 32;
    uint64 id = ((key.high & 0xFFFFFFFF) << 32) | (key.low & 0xFFFFFFFF);
    return {type, id};
}
```

### 2. å†…å­˜ç´¢å¼•ï¼ˆMapï¼‰

#### ä»€ä¹ˆæ˜¯"ç´¢å¼•"ï¼Ÿ

**ç´¢å¼•å°±æ˜¯"ç›®å½•"**ï¼Œå‘Šè¯‰ç³»ç»Ÿ"å»å“ªé‡Œæ‰¾æ•°æ®"ï¼Œå°±åƒå›¾ä¹¦é¦†çš„ä¹¦ç›®å¡ç‰‡ã€‚

```cpp
// æ ¸å¿ƒæ•°æ®ç»“æ„
std::unordered_map<Key, Entry> _map;  // â† è¿™å°±æ˜¯"ç´¢å¼•"

struct Entry {
    PlaceId place;      // ğŸ“ æ•°æ®ä½ç½®ï¼ˆç£ç›˜åœ°å€ï¼Œ7å­—èŠ‚ï¼‰
    uint32 checksum;    // âœ“ æ ¡éªŒå’Œ
    size_type size;     // ğŸ“ æ•°æ®å¤§å°
    uint8 tag;          // ğŸ·ï¸ æ ‡ç­¾ï¼ˆåˆ†ç±»ï¼‰
    uint64 useTime;     // â° æœ€åè®¿é—®æ—¶é—´
};
```

#### å…³é”®æ¦‚å¿µå¯¹æ¯”

| æ¦‚å¿µ | å­˜å‚¨ä½ç½® | å†…å®¹ | å¤§å° | ä½œç”¨ |
|------|---------|------|------|------|
| **ç´¢å¼•ï¼ˆIndexï¼‰** | ğŸ’¾ å†…å­˜ï¼ˆRAMï¼‰ | Key â†’ Entryï¼ˆå…ƒæ•°æ®ï¼‰ | å°ï¼ˆ48B/é”®ï¼‰ | å¿«é€ŸæŸ¥æ‰¾ |
| **æ•°æ®ï¼ˆDataï¼‰** | ğŸ’¿ ç£ç›˜ï¼ˆDiskï¼‰ | å®é™…çš„ Value å†…å®¹ | å¤§ï¼ˆå¯å˜ï¼‰ | çœŸæ­£çš„æ•°æ® |

#### æ•°æ®æµè¯¦è§£

**å†™å…¥æµç¨‹**ï¼š
```cpp
void put(Key key, QByteArray value) {
    // æ­¥éª¤ 1: å°† VALUE å†™å…¥ç£ç›˜
    PlaceId diskPosition = writeToDisk(value);  // ç£ç›˜åœ°å€ï¼Œä¾‹å¦‚ï¼šæ–‡ä»¶0ï¼Œåç§»1024
    
    // æ­¥éª¤ 2: å°†å…ƒæ•°æ®å†™å…¥å†…å­˜ç´¢å¼•
    Entry entry;
    entry.place = diskPosition;     // è®°ä½ç£ç›˜ä½ç½®
    entry.size = value.size();      // è®°ä½å¤§å°
    entry.checksum = xxhash(value); // è®°ä½æ ¡éªŒå’Œ
    entry.useTime = now();          // è®°ä½æ—¶é—´
    
    _map[key] = entry;  // å­˜å…¥å†…å­˜ç´¢å¼•
    
    // æ­¥éª¤ 3: è®°å½•åˆ° binlogï¼ˆå´©æºƒæ¢å¤ç”¨ï¼‰
    writeToBinlog(Store{key, entry});
}
```

**è¯»å–æµç¨‹**ï¼š
```cpp
QByteArray get(Key key) {
    // æ­¥éª¤ 1: ä»å†…å­˜ç´¢å¼•æŸ¥æ‰¾å…ƒæ•°æ®ï¼ˆå¾®ç§’çº§ï¼‰
    auto it = _map.find(key);
    if (it == _map.end()) {
        return {};  // é”®ä¸å­˜åœ¨
    }
    
    Entry &entry = it->second;
    
    // æ­¥éª¤ 2: æ ¹æ®ç£ç›˜ä½ç½®è¯»å–å®é™…æ•°æ®ï¼ˆæ¯«ç§’çº§ï¼‰
    QByteArray value = readFromDisk(entry.place, entry.size);
    
    // æ­¥éª¤ 3: éªŒè¯æ•°æ®å®Œæ•´æ€§
    if (xxhash(value) != entry.checksum) {
        throw CorruptionError();
    }
    
    return value;  // è¿”å›å®é™…æ•°æ®
}
```

#### å›¾è§£ï¼šæ•°æ®åœ¨å“ªé‡Œï¼Ÿ

```
è¿è¡Œæ—¶å†…å­˜å¸ƒå±€ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              RAM (å†…å­˜)                          â”‚
â”‚                                                  â”‚
â”‚  ç´¢å¼•ï¼šstd::unordered_map<Key, Entry>            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ Key{1,2} â†’ Entry{place=0x1000, ...}    â”‚     â”‚
â”‚  â”‚ Key{3,4} â†’ Entry{place=0x2000, ...}    â”‚     â”‚
â”‚  â”‚ Key{5,6} â†’ Entry{place=0x3000, ...}    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚      â†“           â†“           â†“                   â”‚
â”‚    æŒ‡å‘ç£ç›˜    æŒ‡å‘ç£ç›˜    æŒ‡å‘ç£ç›˜               â”‚
â””â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚           â”‚           â”‚
       â–¼           â–¼           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Disk (ç£ç›˜)                         â”‚
â”‚                                                  â”‚
â”‚  æ•°æ®æ–‡ä»¶ï¼š0000.db                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚ 0x1000: [Value1 çš„å®é™…å†…å®¹: å›¾ç‰‡æ•°æ®]   â”‚     â”‚
â”‚  â”‚ 0x2000: [Value2 çš„å®é™…å†…å®¹: æ–‡æœ¬æ•°æ®]   â”‚     â”‚
â”‚  â”‚ 0x3000: [Value3 çš„å®é™…å†…å®¹: JSONæ•°æ®]   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å®é™…ä¾‹å­

å‡è®¾æˆ‘ä»¬å­˜å‚¨ä¸€å¼ å›¾ç‰‡ï¼š

```cpp
// 1. å­˜å‚¨å›¾ç‰‡
Key imageKey = {0x123, 0x456};  // 128 ä½é”®
QByteArray imageData = loadImage("photo.jpg");  // 2MB å›¾ç‰‡

cache.put(imageKey, imageData);

// å†…å­˜ä¸­åªå­˜å‚¨ï¼š
// {
//   key: {0x123, 0x456},
//   place: {fileId=0, offset=1024},  // ç£ç›˜ä½ç½®
//   size: 2097152,                    // 2MB
//   checksum: 0xABCD1234,             // æ ¡éªŒå’Œ
//   useTime: 1730544000               // æ—¶é—´æˆ³
// }
// æ€»å…±çº¦ 48 å­—èŠ‚åœ¨å†…å­˜

// ç£ç›˜ä¸­å­˜å‚¨ï¼š
// æ–‡ä»¶ 0000.db çš„ 1024 å­—èŠ‚åç§»å¤„ï¼š
// [JPEG æ–‡ä»¶å¤´][å›¾ç‰‡æ•°æ®][...] (å®Œæ•´ 2MB)


// 2. è¯»å–å›¾ç‰‡
QByteArray image = cache.get(imageKey);
// â‘  åœ¨å†…å­˜ç´¢å¼•ä¸­æŸ¥æ‰¾ {0x123, 0x456}  â†’ æ‰¾åˆ° Entry
// â‘¡ è¯»å–ç£ç›˜æ–‡ä»¶ 0000.db çš„ offset=1024ï¼Œé•¿åº¦ 2MB
// â‘¢ éªŒè¯æ ¡éªŒå’Œ
// â‘£ è¿”å› 2MB å›¾ç‰‡æ•°æ®
```

#### Value åœ¨è¿è¡Œè¿‡ç¨‹ä¸­åœ¨å“ªé‡Œï¼Ÿ

**ç­”æ¡ˆï¼šé»˜è®¤åœ¨ç£ç›˜ï¼Œå¯é€‰ç¼“å­˜åœ¨å†…å­˜**

```cpp
class DatabaseWithCache {
    // ç´¢å¼•ï¼ˆå¿…é¡»åœ¨å†…å­˜ï¼‰
    std::unordered_map<Key, Entry> _index;
    
    // æ•°æ®ï¼ˆé»˜è®¤åœ¨ç£ç›˜ï¼‰
    // ç£ç›˜æ–‡ä»¶ï¼š0000.db, 0001.db, ...
    
    // å¯é€‰ï¼šçƒ­ç‚¹æ•°æ®ç¼“å­˜ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
    struct LRUCache {
        std::unordered_map<Key, QByteArray> _cache;  // ç¼“å­˜å®é™…æ•°æ®
        size_t _maxSize = 100 * 1024 * 1024;         // é™åˆ¶ 100MB
    } _valueCache;
    
    QByteArray get(Key key) {
        // 1ï¸âƒ£ å…ˆæŸ¥å†…å­˜ç¼“å­˜ï¼ˆå¦‚æœæœ‰ï¼‰
        if (auto cached = _valueCache.get(key)) {
            return *cached;  // å‘½ä¸­ï¼æ— éœ€ç£ç›˜ IO
        }
        
        // 2ï¸âƒ£ ä»ç£ç›˜è¯»å–
        auto entry = _index[key];
        auto value = readFromDisk(entry.place, entry.size);
        
        // 3ï¸âƒ£ åŠ å…¥ç¼“å­˜ï¼ˆä¸‹æ¬¡æ›´å¿«ï¼‰
        _valueCache.put(key, value);
        
        return value;
    }
};
```

#### å†…å­˜å ç”¨å¯¹æ¯”

| åœºæ™¯ | ç´¢å¼•å†…å­˜ | æ•°æ®å†…å­˜ | æ€»å†…å­˜ |
|------|---------|---------|--------|
| **ä»…ç´¢å¼•**ï¼ˆæœ¬ç³»ç»Ÿé»˜è®¤ï¼‰ | 50 MBï¼ˆ100ä¸‡é”®ï¼‰ | 0 | 50 MB |
| **ç´¢å¼• + å°ç¼“å­˜** | 50 MB | 100 MBï¼ˆçƒ­æ•°æ®ï¼‰ | 150 MB |
| **å…¨å†…å­˜**ï¼ˆå¦‚ Redisï¼‰ | 50 MB | 10 GBï¼ˆå…¨éƒ¨æ•°æ®ï¼‰ | 10.05 GB |

#### ä¸ºä»€ä¹ˆè¿™æ ·è®¾è®¡ï¼Ÿ

**ä¼˜åŠ¿**ï¼š
- âœ… **èŠ‚çœå†…å­˜**ï¼šåªæœ‰å…ƒæ•°æ®åœ¨å†…å­˜ï¼ˆ48B vs KB-MB æ•°æ®ï¼‰
- âœ… **æ”¯æŒå¤§æ•°æ®é›†**ï¼šç£ç›˜ä¾¿å®œï¼Œå¯å­˜å‚¨è¿œè¶…å†…å­˜çš„æ•°æ®
- âœ… **å¿«é€ŸæŸ¥æ‰¾**ï¼šç´¢å¼•åœ¨å†…å­˜ï¼Œåˆ¤æ–­å­˜åœ¨æ€§å¾ˆå¿«
- âœ… **æŒ‰éœ€åŠ è½½**ï¼šåªè¯»å–éœ€è¦çš„æ•°æ®

**ä»£ä»·**ï¼š
- âš ï¸ **è¯»å–å»¶è¿Ÿ**ï¼šéœ€è¦ç£ç›˜ IOï¼ˆ1-10msï¼‰
- âš ï¸ **å¯ä¼˜åŒ–**ï¼šå¯ä»¥åŠ äºŒçº§ç¼“å­˜ç¼“è§£

#### æ˜¯çš„ï¼Œè¿™æ˜¯**å…¨å†…å­˜ç´¢å¼•**ï¼

**ç´¢å¼•ç­–ç•¥åˆ†æ**ï¼š
- âœ… **æ‰€æœ‰é”®çš„å…ƒæ•°æ®**éƒ½ä¿å­˜åœ¨å†…å­˜ä¸­ï¼ˆ`_map`ï¼‰
- âœ… **å®é™…æ•°æ®ï¼ˆValueï¼‰** å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼ˆæŒ‰ `PlaceId` å®šä½ï¼‰
- âœ… ç¨‹åºå¯åŠ¨æ—¶é€šè¿‡é‡æ”¾ binlog é‡å»ºå†…å­˜ç´¢å¼•
- âš ï¸ **å†…å­˜å ç”¨**ï¼šæ¯ä¸ªé”®çº¦ 48-64 å­—èŠ‚ï¼ˆä»…å…ƒæ•°æ®ï¼‰
- âš ï¸ **æ•°æ®å ç”¨**ï¼šå­˜å‚¨åœ¨ç£ç›˜ï¼Œå†…å­˜ä¸­é€šå¸¸ä¸ä¿ç•™ï¼ˆé™¤éä½¿ç”¨ç¼“å­˜ï¼‰

#### é€‚ç”¨æ•°æ®é‡çº§

| é”®æ•°é‡ | å†…å­˜å ç”¨ | é€‚ç”¨æ€§ | è¯´æ˜ |
|--------|---------|-------|------|
| **10 ä¸‡** | ~5-6 MB | âœ… å®Œå…¨é€‚åˆ | å‡ ä¹æ„Ÿè§‰ä¸åˆ°å†…å­˜å‹åŠ› |
| **100 ä¸‡** | ~50-60 MB | âœ… éå¸¸é€‚åˆ | ç°ä»£è®¾å¤‡å®Œå…¨å¯ä»¥æ¥å— |
| **1000 ä¸‡** | ~500-600 MB | âš ï¸ å¯æ¥å— | æ¡Œé¢åº”ç”¨å¯è¡Œï¼Œç§»åŠ¨ç«¯éœ€è°¨æ… |
| **1 äº¿** | ~5-6 GB | âŒ ä¸æ¨è | éœ€è¦æ”¹ç”¨ç£ç›˜ç´¢å¼•ï¼ˆLSM Treeï¼‰ |
| **10 äº¿+** | ~50+ GB | âŒ ä¸å¯è¡Œ | å¿…é¡»ä½¿ç”¨åˆ†å±‚ç´¢å¼•æˆ–åˆ†å¸ƒå¼æ–¹æ¡ˆ |

**è®¡ç®—å…¬å¼**ï¼š
```cpp
// Entry ç»“æ„å¤§å°ä¼°ç®—
sizeof(Entry) â‰ˆ 
    7 (PlaceId) + 
    4 (checksum) + 
    4 (size) + 
    1 (tag) + 
    8 (useTime) + 
    padding = ~32 å­—èŠ‚

// unordered_map å¼€é”€ï¼ˆçº¦ 1.5-2xï¼‰
// åŒ…æ‹¬ï¼šå“ˆå¸Œè¡¨æ¡¶ã€æŒ‡é’ˆã€Key å­˜å‚¨ç­‰
å®é™…å†…å­˜ â‰ˆ (sizeof(Key) + sizeof(Entry)) Ã— è´Ÿè½½å› å­
        â‰ˆ (16 + 32) Ã— 1.5-2.0 
        â‰ˆ 48-64 å­—èŠ‚/é”®
```

#### é€‚ç”¨åœºæ™¯

**âœ… éå¸¸é€‚åˆ**ï¼š
1. **æ¡Œé¢åº”ç”¨ç¼“å­˜**
   - å›¾ç‰‡ç¼“å­˜ï¼ˆTelegramã€å¾®ä¿¡ç­‰ï¼‰ï¼šé€šå¸¸ < 100 ä¸‡å¼ 
   - æ–‡ä»¶ç¼“å­˜ï¼šå…ƒæ•°æ®é‡æœ‰é™
   - ç½‘é¡µç¼“å­˜ï¼šæµè§ˆå™¨ç¼“å­˜é€šå¸¸ < 50 ä¸‡æ¡

2. **ç§»åŠ¨åº”ç”¨**
   - ç¦»çº¿æ•°æ®ï¼šé€šå¸¸ < 10 ä¸‡æ¡è®°å½•
   - èŠå¤©è®°å½•ç¼“å­˜ï¼šå³ä½¿ç™¾ä¸‡æ¡æ¶ˆæ¯ï¼Œç´¢å¼•ä¹Ÿå¯æ¥å—
   - èµ„æºæ–‡ä»¶ç¼“å­˜

3. **å°å‹æœåŠ¡**
   - Session å­˜å‚¨ï¼šå•æœº < 100 ä¸‡ä¼šè¯
   - é…ç½®ç¼“å­˜ï¼šé€šå¸¸ < 10 ä¸‡æ¡
   - ä¸´æ—¶æ•°æ®å­˜å‚¨

**âŒ ä¸é€‚åˆ**ï¼š
1. **å¤§æ•°æ®åœºæ™¯**
   - æ•°åäº¿æ¡è®°å½•ï¼šéœ€è¦ LSM Treeï¼ˆLevelDB/RocksDBï¼‰
   - åˆ†å¸ƒå¼ç¼“å­˜ï¼šéœ€è¦ Redis/Memcached
   
2. **å†…å­˜å—é™è®¾å¤‡**
   - IoT è®¾å¤‡ï¼ˆ< 256MB RAMï¼‰ï¼šè¶…è¿‡ 10 ä¸‡é”®å°±åƒåŠ›
   - åµŒå…¥å¼ç³»ç»Ÿï¼šéœ€è¦è€ƒè™‘å†…å­˜ç¢ç‰‡

3. **æ— é™å¢é•¿çš„æ•°æ®**
   - æ—¥å¿—ç³»ç»Ÿï¼šéœ€è¦å®šæœŸå½’æ¡£
   - ç›‘æ§æ•°æ®ï¼šéœ€è¦æ—¶é—´çª—å£é™åˆ¶

#### ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜ç´¢å¼•ï¼Ÿ

**ä¼˜ç‚¹**ï¼š
- âœ… **æå¿«çš„æŸ¥æ‰¾**ï¼šO(1) æŸ¥æ‰¾ï¼Œå¾®ç§’çº§å“åº”
- âœ… **ç®€å•å®ç°**ï¼šæ— éœ€å¤æ‚çš„ç£ç›˜ç´¢å¼•ç»“æ„
- âœ… **æ”¯æŒ LRU**ï¼šå¯ç›´æ¥éå†æ‰€æœ‰é”®æŒ‰æ—¶é—´æ’åº
- âœ… **å´©æºƒæ¢å¤å¿«**ï¼šé€šè¿‡ binlog é‡æ”¾å³å¯é‡å»º

**ç¼ºç‚¹**ï¼š
- âŒ **å†…å­˜é™åˆ¶**ï¼šé”®æ•°é‡å—å†…å­˜å¤§å°çº¦æŸ
- âŒ **å¯åŠ¨æ—¶é—´**ï¼šéœ€è¦é‡æ”¾ binlogï¼ˆç™¾ä¸‡çº§ 1-2 ç§’ï¼‰
- âŒ **å†…å­˜ç¢ç‰‡**ï¼šé•¿æœŸè¿è¡Œå¯èƒ½äº§ç”Ÿç¢ç‰‡

#### å†…å­˜ä¼˜åŒ–æŠ€å·§

```cpp
// æŠ€å·§ 1: ä½¿ç”¨ç´§å‡‘æ•°æ®ç»“æ„ï¼ˆä½åŸŸï¼‰
struct CompactEntry {
    uint64 useTime : 40;   // 40 ä½æ—¶é—´æˆ³ï¼ˆè¶³å¤Ÿ 34 å¹´ï¼‰
    uint64 size : 24;      // 24 ä½å¤§å°ï¼ˆæœ€å¤§ 16MBï¼‰
    uint64 placeHigh : 24; // PlaceId é«˜ä½
    uint32 placeLow;       // PlaceId ä½ä½
    uint32 checksum;
    uint8 tag;
    // æ€»å…± ~24 å­—èŠ‚ï¼ŒèŠ‚çœ 25% å†…å­˜
};

// æŠ€å·§ 2: å»¶è¿ŸåŠ è½½å¤§ç´¢å¼•ï¼ˆæ··åˆç­–ç•¥ï¼‰
class HybridIndex {
    // çƒ­æ•°æ®åœ¨å†…å­˜
    std::unordered_map<Key, Entry> _hotCache;
    
    // å†·æ•°æ®åœ¨ç£ç›˜ç´¢å¼•ï¼ˆB+ Tree æˆ– LSM Treeï¼‰
    DiskIndex _coldIndex;
    
    Entry get(Key key) {
        // å…ˆæŸ¥å†…å­˜
        if (auto it = _hotCache.find(key); it != _hotCache.end()) {
            return it->second;
        }
        // å†æŸ¥ç£ç›˜
        auto entry = _coldIndex.get(key);
        // æå‡ä¸ºçƒ­æ•°æ®
        _hotCache[key] = entry;
        return entry;
    }
};

// æŠ€å·§ 3: ä½¿ç”¨å†…å­˜æ± å‡å°‘ç¢ç‰‡
class PooledMap {
    boost::pool_allocator<std::pair<const Key, Entry>> _allocator;
    std::unordered_map<Key, Entry, 
                       std::hash<Key>, 
                       std::equal_to<Key>,
                       decltype(_allocator)> _map;
};
```

#### å®é™…æ¡ˆä¾‹å¯¹æ¯”

| åº”ç”¨ | æ•°æ®é‡ | ç´¢å¼•ç­–ç•¥ | å†…å­˜å ç”¨ |
|------|--------|---------|---------|
| **Telegram Desktop** | ~50 ä¸‡æ¶ˆæ¯ | å…¨å†…å­˜ç´¢å¼• | ~30-50 MB |
| **Chrome ç¼“å­˜** | ~20 ä¸‡æ–‡ä»¶ | å…¨å†…å­˜ç´¢å¼• | ~15-20 MB |
| **LevelDB** | æ•°åäº¿è®°å½• | LSM Tree åˆ†å±‚ | å‡ ç™¾ MBï¼ˆç´¢å¼•ï¼‰ |
| **Redis** | æ•°ç™¾ä¸‡é”® | å…¨å†…å­˜ï¼ˆæ•°æ®+ç´¢å¼•ï¼‰ | æ•° GB |
| **SQLite** | ä»»æ„å¤§å° | B+ Treeï¼ˆç£ç›˜ï¼‰ | å‡  MBï¼ˆç¼“å­˜ï¼‰ |

#### ä½•æ—¶éœ€è¦å‡çº§ç´¢å¼•ç­–ç•¥ï¼Ÿ

**å‡çº§åˆ°ç£ç›˜ç´¢å¼•ï¼ˆLSM Treeï¼‰çš„ä¿¡å·**ï¼š
```cpp
// 1. å†…å­˜å ç”¨è¶…è¿‡é˜ˆå€¼
if (_map.size() * sizeof(Entry) > 500 * 1024 * 1024) {
    // 500MB+ ç´¢å¼•ï¼Œè€ƒè™‘ LSM Tree
    migrateToLSMTree();
}

// 2. å¯åŠ¨æ—¶é—´è¿‡é•¿
if (binlogReplayTime > 10_seconds) {
    // é‡æ”¾è¶…è¿‡ 10 ç§’ï¼Œè€ƒè™‘ checkpoint
    createCheckpoint();
}

// 3. å†™å…¥æ”¾å¤§ä¸¥é‡
if (_binlog.size() > _totalDataSize * 3) {
    // Binlog æ˜¯æ•°æ®çš„ 3 å€ï¼Œè€ƒè™‘æ›´é«˜æ•ˆçš„æ—¥å¿—
    useStructuredLog();
}
```

### 3. Binlogï¼ˆæ“ä½œæ—¥å¿—ï¼‰

#### è®°å½•ç±»å‹è®¾è®¡

```cpp
// è®°å½•ç±»å‹æšä¸¾
enum RecordType : uint8 {
    Store = 0x01,        // å­˜å‚¨å•ä¸ªé”®å€¼å¯¹
    MultiStore = 0x02,   // æ‰¹é‡å­˜å‚¨
    MultiRemove = 0x03,  // æ‰¹é‡åˆ é™¤
    MultiAccess = 0x04,  // æ‰¹é‡æ›´æ–°è®¿é—®æ—¶é—´
};

// Store è®°å½•æ ¼å¼ï¼ˆå®šé•¿ï¼Œä¾¿äºå¿«é€Ÿè¯»å–ï¼‰
struct Store {
    RecordType type = 0x01;
    uint8 tag;              // åˆ†ç±»æ ‡ç­¾
    uint8 size[3];          // æ•°æ®å¤§å°ï¼ˆ24ä½ï¼‰
    uint8 place[7];         // å­˜å‚¨ä½ç½®ï¼ˆ56ä½ï¼‰
    uint32 checksum;        // æ ¡éªŒå’Œ
    Key key;                // 128ä½é”®
};  // æ€»å¤§å°ï¼š32 å­—èŠ‚ï¼ˆ16å­—èŠ‚å¯¹é½ï¼‰
```

#### Binlog æ–‡ä»¶ç»“æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         BasicHeader (48 bytes)       â”‚  â† æ ¼å¼ç‰ˆæœ¬ã€æ ‡å¿—ä½
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Store Record 1                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  MultiStore Header                   â”‚
â”‚    â”œâ”€ Store Part 1                   â”‚
â”‚    â”œâ”€ Store Part 2                   â”‚
â”‚    â””â”€ Store Part N                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  MultiRemove Header                  â”‚
â”‚    â”œâ”€ Key 1                          â”‚
â”‚    â””â”€ Key N                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ...                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### è¯»å– Binlog æµç¨‹

```cpp
void readBinlog() {
    // 1. æ‰“å¼€æ–‡ä»¶
    if (!_binlog.open(path, Mode::Read, key)) {
        handleError();
    }
    
    // 2. è¯»å–å¹¶éªŒè¯å¤´éƒ¨
    auto header = BinlogWrapper::ReadHeader(_binlog, _settings);
    if (!header) {
        handleCorruption();
    }
    
    // 3. åˆ›å»º Reader å¹¶é‡æ”¾æ“ä½œ
    BinlogWrapper wrapper(_binlog, _settings);
    BinlogReader<Store, StoreWithTime, MultiStore, 
                 MultiStoreWithTime, MultiRemove, 
                 MultiAccess> reader(wrapper);
    
    reader.readTillEnd(
        [&](const Store *record) { 
            processStore(record); 
        },
        [&](const MultiRemove &header, const Key *keys) { 
            processRemove(keys); 
        }
        // ... å…¶ä»–å¤„ç†å™¨
    );
}
```

### 4. æ•°æ®æ–‡ä»¶å¸ƒå±€

#### PlaceId è®¾è®¡

```cpp
using PlaceId = std::array<uint8, 7>;  // 56 ä½

// ç¼–ç æ–¹å¼ï¼š
// [0-15 ä½]: æ–‡ä»¶ç¼–å·ï¼ˆ65536 ä¸ªæ–‡ä»¶ï¼‰
// [16-55 ä½]: æ–‡ä»¶å†…åç§»ï¼ˆæœ€å¤§ 1TB æ¯æ–‡ä»¶ï¼‰

PlaceId encodePlace(uint16 fileId, uint64 offset) {
    uint64 combined = (uint64(fileId) << 40) | offset;
    PlaceId result;
    for (int i = 0; i < 7; i++) {
        result[i] = (combined >> (i * 8)) & 0xFF;
    }
    return result;
}
```

#### æ•°æ®æ–‡ä»¶å‘½å

```
cache_root/
  â”œâ”€ version                  â† ç‰ˆæœ¬æ–‡ä»¶
  â”œâ”€ 0/                       â† ç‰ˆæœ¬ 0 ç›®å½•
  â”‚   â”œâ”€ binlog               â† æ“ä½œæ—¥å¿—
  â”‚   â”œâ”€ 0000.db             â† æ•°æ®æ–‡ä»¶ 0
  â”‚   â”œâ”€ 0001.db             â† æ•°æ®æ–‡ä»¶ 1
  â”‚   â””â”€ ...
  â””â”€ 1/                       â† ç‰ˆæœ¬ 1 ç›®å½•ï¼ˆå‹ç¼©åï¼‰
      â”œâ”€ binlog
      â””â”€ ...
```

### 5. Cleanerï¼ˆæ¸…ç†å™¨ï¼‰

#### æ¸…ç†ç­–ç•¥

```cpp
// è§¦å‘æ¡ä»¶
bool needClean() {
    return _totalSize > _settings.totalSizeLimit ||
           hasExpiredData();
}

// LRU æ¸…ç†
void collectSizeStale(flat_set<Key> &stale) {
    // 1. æŒ‰è®¿é—®æ—¶é—´æ’åº
    std::vector<Entry*> entries;
    for (auto &[key, entry] : _map) {
        entries.push_back(&entry);
    }
    
    // 2. ä»æœ€æ—§çš„å¼€å§‹åˆ é™¤
    std::sort(entries.begin(), entries.end(), 
        [](Entry *a, Entry *b) { 
            return a->useTime < b->useTime; 
        });
    
    // 3. åˆ é™¤ç›´åˆ°ä½äºé˜ˆå€¼
    int64 toRemove = _totalSize - _settings.totalSizeLimit;
    for (auto *entry : entries) {
        if (toRemove <= 0) break;
        stale.insert(entry->key);
        toRemove -= entry->size;
    }
}

// æ—¶é—´è¿‡æœŸæ¸…ç†
void collectTimeStale(flat_set<Key> &stale) {
    uint64 expireTime = currentTime() - _settings.totalTimeLimit;
    
    for (auto &[key, entry] : _map) {
        if (entry.useTime < expireTime) {
            stale.insert(key);
        }
    }
}
```

#### åˆ†æ‰¹æ¸…ç†é¿å…å¡é¡¿

```cpp
void clearStaleChunk() {
    // æ¯æ¬¡åªæ¸…ç† 256 ä¸ªæ¡ç›®
    size_t count = std::min(_stale.size(), 
                            _settings.staleRemoveChunk);
    
    for (size_t i = 0; i < count; i++) {
        remove(_stale.back());
        _stale.pop_back();
    }
    
    // å¦‚æœè¿˜æœ‰å‰©ä½™ï¼Œå»¶è¿Ÿå¤„ç†
    if (!_stale.empty()) {
        scheduleNextChunk();
    }
}
```

### 6. Compactorï¼ˆå‹ç¼©å™¨ï¼‰

#### ä¸ºä»€ä¹ˆéœ€è¦å‹ç¼©ï¼Ÿ

```
åˆå§‹ Binlog:
[Store A] [Store B] [Store C] [Remove B] [Store D] [Remove C]
                                â†“
å‹ç¼©å Binlog:
[Store A] [Store D]  â† èŠ‚çœ 66% ç©ºé—´
```

#### å‹ç¼©æµç¨‹

```cpp
void compact() {
    // 1. åˆ›å»ºæ–°çš„ä¸´æ—¶ binlog
    File newBinlog;
    newBinlog.open(tempPath, Mode::Write, _key);
    
    // 2. å†™å…¥å¤´éƒ¨
    newBinlog.write(header);
    
    // 3. éå†å½“å‰æœ‰æ•ˆé”®
    for (auto &[key, entry] : _map) {
        // è¯»å–åŸå§‹æ•°æ®
        auto data = readValueData(entry.place, entry.size);
        
        // åˆ†é…æ–°ä½ç½®
        PlaceId newPlace = allocatePlace(data.size());
        
        // å†™å…¥æ–°ä½ç½®
        writeData(newPlace, data);
        
        // å†™å…¥æ–° binlog è®°å½•
        Store record;
        record.key = key;
        record.place = newPlace;
        record.size = data.size();
        record.checksum = calculateChecksum(data);
        newBinlog.write(record);
    }
    
    // 4. åŸå­æ›¿æ¢
    atomicRename(tempPath, binlogPath);
}
```

#### å¢é‡å‹ç¼©

```cpp
// é—®é¢˜ï¼šå¤§æ•°æ®åº“å‹ç¼©å¾ˆæ…¢
// è§£å†³ï¼šè¾¹è¿è¡Œè¾¹å‹ç¼©

void incrementalCompact() {
    // 1. å¤åˆ¶å½“å‰ binlog åˆ° compact.tmp
    copyFile(binlogPath, compactPath);
    
    // 2. è¿½åŠ æ–°æ“ä½œåˆ° compact.tmp
    int64 readTill = getBinlogSize();
    
    while (running) {
        // å¤„ç†ä¸€æ‰¹é”®
        auto keys = readChunk();
        compactKeys(keys);
        
        // è¿½åŠ æ–°å¢çš„æ“ä½œ
        catchUp(readTill, getBinlogSize());
        
        if (finished) break;
    }
    
    // 3. å¿«é€Ÿåˆ‡æ¢
    atomicSwitch();
}
```

---

## æ•°æ®ç»“æ„è®¾è®¡

### 1. å›ºå®šé•¿åº¦ vs å˜é•¿è®°å½•

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|---------|
| **å›ºå®šé•¿åº¦** | â€¢ å¿«é€Ÿéšæœºè®¿é—®<br>â€¢ ç®€å•å®ç°<br>â€¢ æ— ç¢ç‰‡ | â€¢ æµªè´¹ç©ºé—´<br>â€¢ å¤§å°å—é™ | å…ƒæ•°æ®ã€ç´¢å¼• |
| **å˜é•¿è®°å½•** | â€¢ èŠ‚çœç©ºé—´<br>â€¢ çµæ´» | â€¢ å¤æ‚å®ç°<br>â€¢ å¯èƒ½ç¢ç‰‡åŒ– | å®é™…æ•°æ® |

**æœ¬ç³»ç»Ÿé‡‡ç”¨æ··åˆæ–¹æ¡ˆ**ï¼š
- Binlog è®°å½•ï¼šå›ºå®šé•¿åº¦ï¼ˆ32/48 å­—èŠ‚ï¼‰
- å®é™…æ•°æ®ï¼šå˜é•¿å­˜å‚¨

### 2. å­—èŠ‚åºé€‰æ‹©

```cpp
// ç»Ÿä¸€ä½¿ç”¨å°ç«¯åºï¼ˆLittle-Endianï¼‰
// åŸå› ï¼š
// 1. ä¸»æµ CPUï¼ˆx86/ARMï¼‰åŸç”Ÿæ”¯æŒ
// 2. é¿å…å­—èŠ‚åºè½¬æ¢å¼€é”€
// 3. ä¸ç½‘ç»œåºä¸åŒï¼Œä½†æœ¬åœ°å­˜å‚¨æ— éœ€è½¬æ¢

void writeUint64(uint8 *buf, uint64 value) {
    for (int i = 0; i < 8; i++) {
        buf[i] = (value >> (i * 8)) & 0xFF;
    }
}
```

### 3. å¯¹é½ä¸å¡«å……

```cpp
// ä¸ºä»€ä¹ˆè¦ 16 å­—èŠ‚å¯¹é½ï¼Ÿ
// 1. AES åŠ å¯†è¦æ±‚
// 2. CPU ç¼“å­˜è¡Œå¯¹é½ï¼ˆæ€§èƒ½ï¼‰
// 3. åŸå­æ“ä½œè¦æ±‚

static_assert(sizeof(Store) % 16 == 0, 
              "Record must be 16-byte aligned");

// ä½¿ç”¨å¡«å……å­—æ®µ
struct Store {
    // ... å®é™…å­—æ®µ
    uint32 reserved1 = 0;  // å¡«å……åˆ° 16 å­—èŠ‚å€æ•°
    uint32 reserved2 = 0;
};
```

---

## æŒä¹…åŒ–ç­–ç•¥

### 1. å†™å…¥æ—¶æœº

```cpp
// ç­–ç•¥ 1: ç«‹å³å†™å…¥ï¼ˆWrite-Throughï¼‰
void put(Key key, Value value) {
    writeToBinlog(Store{key, ...});  // ç«‹å³å†™ç£ç›˜
    _binlog.flush();                 // å¼ºåˆ¶åˆ·ç›˜
    updateMemoryIndex(key, value);
}
// ä¼˜ç‚¹ï¼šæ•°æ®å®‰å…¨
// ç¼ºç‚¹ï¼šæ€§èƒ½å·®ï¼ˆæ¯æ¬¡å†™å…¥éƒ½æœ‰ç£ç›˜IOï¼‰

// ç­–ç•¥ 2: å»¶è¿Ÿæ‰¹é‡å†™å…¥ï¼ˆWrite-Behindï¼‰
void put(Key key, Value value) {
    _pendingWrites.push_back({key, value});
    updateMemoryIndex(key, value);
    
    if (!_flushTimer.isActive()) {
        _flushTimer.start(15min);  // 15åˆ†é’Ÿåæ‰¹é‡å†™å…¥
    }
}
// ä¼˜ç‚¹ï¼šæ€§èƒ½å¥½ï¼ˆæ‰¹é‡IOï¼‰
// ç¼ºç‚¹ï¼šå´©æºƒå¯èƒ½ä¸¢å¤± 15 åˆ†é’Ÿæ•°æ®

// ç­–ç•¥ 3: æ··åˆç­–ç•¥ï¼ˆæœ¬ç³»ç»Ÿé‡‡ç”¨ï¼‰
void put(Key key, Value value) {
    // é‡è¦æ•°æ®ç«‹å³å†™
    if (isImportant(value)) {
        writeImmediately();
    } else {
        scheduleBatchWrite();
    }
}
```

### 2. åŒæ­¥ vs å¼‚æ­¥

```cpp
// fsync() ç¡®ä¿æ•°æ®çœŸæ­£å†™å…¥ç£ç›˜
bool flush() {
    _file.write(data);
    
    #ifdef ENSURE_DURABILITY
        return _file.fsync();  // é˜»å¡ç›´åˆ°å†™å…¥å®Œæˆ
    #else
        return _file.flush();  // ä»…åˆ·æ–°OSç¼“å†²åŒº
    #endif
}
```

### 3. å´©æºƒæ¢å¤æµç¨‹

```mermaid
graph TD
    A[ç¨‹åºå¯åŠ¨] --> B{Binlog å­˜åœ¨?}
    B -->|å¦| C[åˆ›å»ºæ–° Binlog]
    B -->|æ˜¯| D[è¯»å– Header]
    D --> E{Header æœ‰æ•ˆ?}
    E -->|å¦| F[æ•°æ®æŸåå¤„ç†]
    E -->|æ˜¯| G[é€æ¡è¯»å–è®°å½•]
    G --> H{è®°å½•å®Œæ•´?}
    H -->|å¦| I[æˆªæ–­æŸåéƒ¨åˆ†]
    H -->|æ˜¯| J[é‡æ”¾æ“ä½œ]
    J --> K[é‡å»ºå†…å­˜ç´¢å¼•]
    K --> L[æ¢å¤å®Œæˆ]
```

```cpp
void recover() {
    try {
        readBinlog();
        _recovered = true;
    } catch (CorruptionError &e) {
        // æ–¹æ¡ˆ1: æˆªæ–­æŸåéƒ¨åˆ†ï¼Œä¸¢å¤±éƒ¨åˆ†æ•°æ®
        truncateAtLastGoodRecord();
        
        // æ–¹æ¡ˆ2: å…¨éƒ¨æ¸…ç©ºï¼Œé‡æ–°å¼€å§‹
        if (_settings.clearOnCorruption) {
            clearAll();
        }
    }
}
```

---

## æ€§èƒ½ä¼˜åŒ–æŠ€æœ¯

### 1. æ‰¹é‡æ“ä½œ

```cpp
// å•ä¸ªæ“ä½œ
for (int i = 0; i < 10000; i++) {
    put(key[i], value[i]);  // 10000 æ¬¡ç£ç›˜IO
}

// æ‰¹é‡æ“ä½œ
putBatch(keys, values);  // 1 æ¬¡ç£ç›˜IOï¼ˆMultiStoreï¼‰

// å®ç°
struct MultiStore {
    RecordType type = 0x02;
    uint32 count;  // åç»­è®°å½•æ•°
};

// Binlog å¸ƒå±€ï¼š
// [MultiStore Header][Store 1][Store 2]...[Store N]
```

### 2. é¢„åˆ†é…æ–‡ä»¶ç©ºé—´

```cpp
void createFile(size_t initialSize) {
    _file.create(path);
    
    // é¢„åˆ†é…é¿å…é¢‘ç¹æ‰©å±•
    #ifdef _WIN32
        SetFilePointerEx(handle, initialSize, NULL, FILE_BEGIN);
        SetEndOfFile(handle);
    #else
        fallocate(fd, 0, 0, initialSize);
    #endif
}
```

### 3. mmapï¼ˆå†…å­˜æ˜ å°„ï¼‰

```cpp
// é€‚ç”¨åœºæ™¯ï¼šé¢‘ç¹éšæœºè¯»å–
class MmapFile {
    void *_map;
    size_t _size;
    
    void open(const QString &path) {
        int fd = ::open(path.toUtf8(), O_RDONLY);
        _size = getFileSize(fd);
        _map = mmap(NULL, _size, PROT_READ, 
                    MAP_SHARED, fd, 0);
    }
    
    QByteArray read(size_t offset, size_t size) {
        // ç›´æ¥è®¿é—®å†…å­˜ï¼Œæ—  read() ç³»ç»Ÿè°ƒç”¨
        return QByteArray((char*)_map + offset, size);
    }
};

// æ³¨æ„ï¼šä¸é€‚åˆé¢‘ç¹å†™å…¥ï¼ˆéœ€è¦ msyncï¼‰
```

### 4. ç¼“å­˜çƒ­ç‚¹æ•°æ®

```cpp
class Cache {
    struct LRUCache {
        std::list<std::pair<Key, QByteArray>> _list;
        std::unordered_map<Key, decltype(_list)::iterator> _map;
        size_t _maxSize = 100 * 1024 * 1024;  // 100MB
        
        std::optional<QByteArray> get(const Key &key) {
            auto it = _map.find(key);
            if (it != _map.end()) {
                // ç§»åˆ°æœ€å‰ï¼ˆæœ€è¿‘ä½¿ç”¨ï¼‰
                _list.splice(_list.begin(), _list, it->second);
                return it->second->second;
            }
            return {};
        }
        
        void put(const Key &key, QByteArray value) {
            evictIfNeeded();
            _list.push_front({key, std::move(value)});
            _map[key] = _list.begin();
        }
    };
    
    LRUCache _hotCache;
};
```

### 5. é›¶æ‹·è´æŠ€æœ¯

```cpp
// ä¼ ç»Ÿæ–¹å¼ï¼šå¤šæ¬¡æ‹·è´
QByteArray traditionalRead() {
    char buffer[4096];
    read(fd, buffer, 4096);         // å†…æ ¸ â†’ ç”¨æˆ·ç©ºé—´
    QByteArray data(buffer, 4096);  // æ‹·è´åˆ° QByteArray
    return data;                    // å†æ¬¡æ‹·è´
}

// ä¼˜åŒ–ï¼šå‡å°‘æ‹·è´
QByteArray optimizedRead() {
    QByteArray data(4096, Qt::Uninitialized);
    read(fd, data.data(), 4096);    // ç›´æ¥è¯»å…¥ QByteArray
    return data;                    // RVO/moveï¼Œæ— æ‹·è´
}

// æœ€ä½³ï¼šå…±äº«å†…å­˜
std::shared_ptr<QByteArray> sharedRead() {
    auto data = std::make_shared<QByteArray>();
    // ... è¯»å–
    return data;  // å…±äº«æŒ‡é’ˆï¼Œæ— æ‹·è´
}
```

---

## å¯é æ€§ä¿è¯

### 1. é”™è¯¯å¤„ç†ç­–ç•¥

```cpp
enum class ErrorSeverity {
    Recoverable,    // å¯æ¢å¤é”™è¯¯ï¼ˆé‡è¯•ï¼‰
    DataLoss,       // æ•°æ®ä¸¢å¤±ï¼ˆé™çº§æœåŠ¡ï¼‰
    Corruption,     // æ•°æ®æŸåï¼ˆéœ€è¦ä¿®å¤ï¼‰
    Fatal,          // è‡´å‘½é”™è¯¯ï¼ˆåœæ­¢æœåŠ¡ï¼‰
};

void handleError(Error error) {
    switch (classifyError(error)) {
        case ErrorSeverity::Recoverable:
            logWarning(error);
            retry();
            break;
            
        case ErrorSeverity::DataLoss:
            logError(error);
            notifyUser("éƒ¨åˆ†æ•°æ®å¯èƒ½ä¸¢å¤±");
            continueWithDegradedMode();
            break;
            
        case ErrorSeverity::Corruption:
            logCritical(error);
            attemptRepair();
            if (!repaired) {
                clearAndRebuild();
            }
            break;
            
        case ErrorSeverity::Fatal:
            logFatal(error);
            shutdownGracefully();
            break;
    }
}
```

### 2. æ ¡éªŒå’Œé€‰æ‹©

```cpp
// é€‰é¡¹ 1: CRC32ï¼ˆå¿«é€Ÿï¼Œå†²çªç‡è¾ƒé«˜ï¼‰
uint32 crc32(const QByteArray &data) {
    return qChecksum(data.data(), data.size());
}

// é€‰é¡¹ 2: xxHashï¼ˆå¿«é€Ÿï¼Œå†²çªç‡ä½ï¼‰
uint32 xxhash32(const QByteArray &data) {
    return XXH32(data.data(), data.size(), 0);
}

// é€‰é¡¹ 3: SHA256ï¼ˆæ…¢ï¼ŒåŠ å¯†çº§å®‰å…¨ï¼‰
QByteArray sha256(const QByteArray &data) {
    return QCryptographicHash::hash(data, 
                QCryptographicHash::Sha256);
}

// æ¨èï¼šxxHashï¼ˆæ€§èƒ½ä¸å®‰å…¨å¹³è¡¡ï¼‰
```

### 3. æ•°æ®éªŒè¯

```cpp
bool validateEntry(const Entry &entry) {
    // 1. è¯»å–æ•°æ®
    auto data = readValueData(entry.place, entry.size);
    
    // 2. éªŒè¯å¤§å°
    if (data.size() != entry.size) {
        logError("Size mismatch");
        return false;
    }
    
    // 3. éªŒè¯æ ¡éªŒå’Œ
    uint32 actualChecksum = xxhash32(data);
    if (actualChecksum != entry.checksum) {
        logError("Checksum mismatch");
        return false;
    }
    
    return true;
}

// å®šæœŸåå°éªŒè¯
void backgroundScrub() {
    for (auto &[key, entry] : _map) {
        if (!validateEntry(entry)) {
            remove(key);  // åˆ é™¤æŸåæ•°æ®
            logCorruption(key);
        }
    }
}
```

### 4. æ–‡ä»¶é”

```cpp
class FileLock {
public:
    enum class Result {
        Success,
        AlreadyLocked,
        Failed
    };
    
    Result tryLock(const QString &path) {
        #ifdef _WIN32
            _handle = CreateFile(
                path.toStdWString().c_str(),
                GENERIC_READ | GENERIC_WRITE,
                0,  // ç‹¬å è®¿é—®
                NULL,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );
            
            if (_handle == INVALID_HANDLE_VALUE) {
                return (GetLastError() == ERROR_SHARING_VIOLATION)
                    ? Result::AlreadyLocked
                    : Result::Failed;
            }
        #else
            int fd = open(path.toUtf8(), O_RDWR | O_CREAT, 0644);
            if (flock(fd, LOCK_EX | LOCK_NB) != 0) {
                return (errno == EWOULDBLOCK)
                    ? Result::AlreadyLocked
                    : Result::Failed;
            }
        #endif
        
        return Result::Success;
    }
};
```

---

## å®ç°æ­¥éª¤

### é˜¶æ®µ 1ï¼šæœ€å°å¯ç”¨ç‰ˆæœ¬ï¼ˆMVPï¼‰

**ç›®æ ‡**ï¼šå®ç°åŸºæœ¬çš„ put/get/remove åŠŸèƒ½

```cpp
// 1. å®šä¹‰æ•°æ®ç»“æ„
struct Key { uint64 high, low; };
struct Value { QByteArray data; };

// 2. å†…å­˜ç´¢å¼•
std::unordered_map<Key, Value> _cache;

// 3. åŸºæœ¬æ“ä½œ
void put(Key key, Value value) {
    _cache[key] = std::move(value);
}

std::optional<Value> get(Key key) {
    auto it = _cache.find(key);
    return (it != _cache.end()) 
        ? std::optional(it->second) 
        : std::nullopt;
}

// 4. ç®€å•æŒä¹…åŒ–ï¼ˆåºåˆ—åŒ–æ•´ä¸ª mapï¼‰
void save() {
    QFile file("cache.dat");
    file.open(QIODevice::WriteOnly);
    QDataStream stream(&file);
    stream << _cache.size();
    for (auto &[k, v] : _cache) {
        stream << k.high << k.low << v.data;
    }
}

void load() {
    QFile file("cache.dat");
    file.open(QIODevice::ReadOnly);
    QDataStream stream(&file);
    size_t size;
    stream >> size;
    for (size_t i = 0; i < size; i++) {
        Key k;
        QByteArray data;
        stream >> k.high >> k.low >> data;
        _cache[k] = Value{data};
    }
}
```

**æµ‹è¯• MVP**ï¼š
```cpp
// åŸºæœ¬åŠŸèƒ½æµ‹è¯•
void testMVP() {
    Cache cache;
    
    // å†™å…¥
    cache.put(Key{1, 2}, Value{"hello"});
    cache.put(Key{3, 4}, Value{"world"});
    
    // è¯»å–
    assert(cache.get(Key{1, 2})->data == "hello");
    
    // æŒä¹…åŒ–
    cache.save();
    
    // æ¢å¤
    Cache cache2;
    cache2.load();
    assert(cache2.get(Key{1, 2})->data == "hello");
}
```

### é˜¶æ®µ 2ï¼šæ·»åŠ  WAL

**ç›®æ ‡**ï¼šæ”¯æŒå´©æºƒæ¢å¤

```cpp
class CacheV2 {
    File _binlog;
    std::unordered_map<Key, Entry> _index;
    
    void put(Key key, Value value) {
        // 1. å†™å…¥ binlog
        Store record;
        record.key = key;
        record.size = value.size();
        record.checksum = xxhash32(value);
        _binlog.write(&record, sizeof(record));
        _binlog.flush();
        
        // 2. å†™å…¥æ•°æ®æ–‡ä»¶
        PlaceId place = writeData(value);
        
        // 3. æ›´æ–°ç´¢å¼•
        _index[key] = Entry{place, record.size, record.checksum};
    }
    
    void recover() {
        _binlog.open("cache.binlog");
        
        while (!_binlog.eof()) {
            Store record;
            if (_binlog.read(&record, sizeof(record)) != sizeof(record)) {
                break;  // æ–‡ä»¶ç»“æŸæˆ–æŸå
            }
            
            // éªŒè¯å¹¶é‡å»ºç´¢å¼•
            if (validateRecord(record)) {
                _index[record.key] = extractEntry(record);
            }
        }
    }
};
```

### é˜¶æ®µ 3ï¼šä¼˜åŒ–æ€§èƒ½

**æ·»åŠ åŠŸèƒ½**ï¼š
- æ‰¹é‡æ“ä½œ
- å†…å­˜ç¼“å­˜
- åå°å‹ç¼©

```cpp
class CacheV3 {
    // æ‰¹é‡å†™å…¥
    std::vector<Store> _pendingWrites;
    
    void put(Key key, Value value) {
        _pendingWrites.push_back(createRecord(key, value));
        
        if (_pendingWrites.size() >= 1000) {
            flushBatch();
        }
    }
    
    void flushBatch() {
        // å†™å…¥ MultiStore è®°å½•
        MultiStore header(_pendingWrites.size());
        _binlog.write(&header, sizeof(header));
        
        for (auto &record : _pendingWrites) {
            _binlog.write(&record, sizeof(record));
        }
        
        _binlog.flush();
        _pendingWrites.clear();
    }
};
```

### é˜¶æ®µ 4ï¼šå®Œå–„åŠŸèƒ½

**æ·»åŠ **ï¼š
- åŠ å¯†æ”¯æŒ
- ç©ºé—´å›æ”¶ï¼ˆCleanerï¼‰
- æ—¥å¿—å‹ç¼©ï¼ˆCompactorï¼‰
- ç»Ÿè®¡ä¿¡æ¯
- é”™è¯¯æ¢å¤

---

## æœ€ä½³å®è·µ

### 1. é…ç½®è°ƒä¼˜

```cpp
// æ¡Œé¢åº”ç”¨ï¼ˆå¤§ç¼“å­˜ï¼‰
Settings desktopSettings {
    .totalSizeLimit = 2 * 1024 * 1024 * 1024,  // 2GB
    .totalTimeLimit = 90 * 24 * 60 * 60,       // 90å¤©
    .compactAfterExcess = 100 * 1024 * 1024,   // 100MB
    .maxBundledRecords = 10000,
};

// ç§»åŠ¨åº”ç”¨ï¼ˆå°ç¼“å­˜ï¼‰
Settings mobileSettings {
    .totalSizeLimit = 100 * 1024 * 1024,       // 100MB
    .totalTimeLimit = 7 * 24 * 60 * 60,        // 7å¤©
    .compactAfterExcess = 10 * 1024 * 1024,    // 10MB
    .maxBundledRecords = 1000,
};

// åµŒå…¥å¼è®¾å¤‡ï¼ˆæå°ç¼“å­˜ï¼‰
Settings embeddedSettings {
    .totalSizeLimit = 10 * 1024 * 1024,        // 10MB
    .totalTimeLimit = 24 * 60 * 60,            // 1å¤©
    .compactAfterExcess = 1 * 1024 * 1024,     // 1MB
    .maxBundledRecords = 100,
};
```

### 2. ç›‘æ§æŒ‡æ ‡

```cpp
struct Metrics {
    // æ€§èƒ½æŒ‡æ ‡
    size_t totalKeys;
    int64 totalSize;
    double hitRate;           // å‘½ä¸­ç‡
    double avgReadLatency;    // å¹³å‡è¯»å»¶è¿Ÿ
    double avgWriteLatency;   // å¹³å‡å†™å»¶è¿Ÿ
    
    // å¥åº·æŒ‡æ ‡
    size_t corruptedEntries;  // æŸåæ¡ç›®æ•°
    int64 binlogSize;         // Binlog å¤§å°
    double fragmentationRate; // ç¢ç‰‡ç‡
    
    // æ“ä½œè®¡æ•°
    uint64 putCount;
    uint64 getCount;
    uint64 removeCount;
    uint64 missCount;
};

void logMetrics() {
    auto m = collectMetrics();
    
    qDebug() << "Cache Stats:";
    qDebug() << "  Keys:" << m.totalKeys;
    qDebug() << "  Size:" << formatSize(m.totalSize);
    qDebug() << "  Hit Rate:" << m.hitRate * 100 << "%";
    
    if (m.fragmentationRate > 0.5) {
        qWarning() << "High fragmentation, consider compacting";
    }
}
```

### 3. å¸¸è§é™·é˜±

#### é™·é˜± 1ï¼šå¿˜è®°åˆ·ç›˜

```cpp
// âŒ é”™è¯¯ï¼šæ•°æ®å¯èƒ½ä¸¢å¤±
void put(Key key, Value value) {
    _binlog.write(record);
    // å´©æºƒæ—¶æ•°æ®åœ¨ OS ç¼“å†²åŒºï¼Œæœªå†™å…¥ç£ç›˜
}

// âœ… æ­£ç¡®ï¼šç¡®ä¿æŒä¹…åŒ–
void put(Key key, Value value) {
    _binlog.write(record);
    _binlog.flush();     // åˆ·æ–° OS ç¼“å†²åŒº
    _binlog.fsync();     // ç¡®ä¿å†™å…¥ç£ç›˜
}

// âš¡ æŠ˜è¡·ï¼šæ‰¹é‡åˆ·ç›˜
void flushBatch() {
    for (auto &record : batch) {
        _binlog.write(record);
    }
    _binlog.fsync();  // ä¸€æ¬¡æ€§åˆ·ç›˜
}
```

#### é™·é˜± 2ï¼šå†…å­˜æ³„æ¼

```cpp
// âŒ é”™è¯¯ï¼šç´¢å¼•æ°¸è¿œå¢é•¿
void put(Key key, Value value) {
    _index[key] = Entry{...};
    _totalSize += value.size();
    // ä»ä¸æ¸…ç†ï¼
}

// âœ… æ­£ç¡®ï¼šå®šæœŸæ¸…ç†
void put(Key key, Value value) {
    auto it = _index.find(key);
    if (it != _index.end()) {
        _totalSize -= it->second.size;  // å‡å»æ—§å¤§å°
    }
    
    _index[key] = Entry{...};
    _totalSize += value.size();
    
    if (_totalSize > _settings.totalSizeLimit) {
        cleanup();  // è§¦å‘æ¸…ç†
    }
}
```

#### é™·é˜± 3ï¼šç«æ€æ¡ä»¶

```cpp
// âŒ é”™è¯¯ï¼šå¤šçº¿ç¨‹ä¸å®‰å…¨
void put(Key key, Value value) {
    _cache[key] = value;  // ç«æ€ï¼
}

// âœ… æ–¹æ¡ˆ1ï¼šåŠ é”
std::mutex _mutex;
void put(Key key, Value value) {
    std::lock_guard lock(_mutex);
    _cache[key] = value;
}

// âœ… æ–¹æ¡ˆ2ï¼šå•çº¿ç¨‹æ¨¡å‹ï¼ˆæ¨èï¼‰
void put(Key key, Value value) {
    _queue.post([=] {
        _cache[key] = value;  // æ€»æ˜¯åœ¨åŒä¸€çº¿ç¨‹æ‰§è¡Œ
    });
}
```

### 4. æµ‹è¯•ç­–ç•¥

```cpp
// 1. å•å…ƒæµ‹è¯•
TEST_CASE("Basic operations") {
    Cache cache;
    cache.put(key1, value1);
    REQUIRE(cache.get(key1) == value1);
    cache.remove(key1);
    REQUIRE(!cache.get(key1).has_value());
}

// 2. å´©æºƒæµ‹è¯•
TEST_CASE("Crash recovery") {
    {
        Cache cache;
        cache.put(key1, value1);
        // æ¨¡æ‹Ÿå´©æºƒï¼ˆä¸è°ƒç”¨ closeï¼‰
    }
    
    // é‡æ–°æ‰“å¼€
    Cache cache2;
    REQUIRE(cache2.get(key1) == value1);
}

// 3. å‹åŠ›æµ‹è¯•
TEST_CASE("Stress test") {
    Cache cache;
    
    // å†™å…¥ 100 ä¸‡æ¡è®°å½•
    for (int i = 0; i < 1000000; i++) {
        cache.put(Key{i, 0}, generateValue());
    }
    
    // éªŒè¯æ€§èƒ½
    auto start = now();
    cache.get(Key{500000, 0});
    auto latency = now() - start;
    
    REQUIRE(latency < 1ms);  // è¯»å–å»¶è¿Ÿ < 1ms
}

// 4. å¹¶å‘æµ‹è¯•
TEST_CASE("Concurrent access") {
    Cache cache;
    
    std::vector<std::thread> threads;
    for (int i = 0; i < 10; i++) {
        threads.emplace_back([&, i] {
            for (int j = 0; j < 10000; j++) {
                cache.put(Key{i, j}, value);
            }
        });
    }
    
    for (auto &t : threads) t.join();
    
    REQUIRE(cache.size() == 100000);
}
```

---

## ä¸ LevelDB çš„å¯¹æ¯”

### æ¶æ„å·®å¼‚

| ç‰¹æ€§ | Desktop App Cache | LevelDB |
|------|------------------|---------|
| **ç´¢å¼•ç­–ç•¥** | å…¨å†…å­˜ HashMap | LSM Treeï¼ˆåˆ†å±‚ç£ç›˜ï¼‰ |
| **æ•°æ®ç»“æ„** | æ‰å¹³ Key-Value | SSTable + MemTable |
| **å†™å…¥æ–¹å¼** | Binlogï¼ˆè¿½åŠ æ—¥å¿—ï¼‰ | WAL + Compaction |
| **è¯»å–è·¯å¾„** | å†…å­˜ç´¢å¼• â†’ ç£ç›˜æ•°æ® | MemTable â†’ Level0-N |
| **å‹ç¼©ç­–ç•¥** | ç®€å•é‡å†™ | å¤šå±‚åˆå¹¶ï¼ˆTiered/Leveledï¼‰ |
| **å¹¶å‘æ¨¡å‹** | å•çº¿ç¨‹ + é˜Ÿåˆ— | å¤šçº¿ç¨‹ + é” |

### ä¼˜åŠ¿å¯¹æ¯”

#### æœ¬ç³»ç»Ÿçš„ä¼˜åŠ¿ âœ…

**1. æè‡´çš„è¯»å–æ€§èƒ½ï¼ˆå°æ•°æ®é›†ï¼‰**
```cpp
// æœ¬ç³»ç»Ÿï¼šO(1) å†…å­˜æŸ¥æ‰¾
QByteArray get(Key key) {
    auto it = _map.find(key);           // < 1Î¼sï¼ˆå†…å­˜ï¼‰
    if (it == _map.end()) return {};
    return readFromDisk(it->place);     // 1-10msï¼ˆSSDï¼‰
}
// æ€»è€—æ—¶ï¼š~1-10ms

// LevelDBï¼šå¤šå±‚æŸ¥æ‰¾
QByteArray get(Key key) {
    if (auto val = memtable.get(key))   // < 1Î¼s
        return val;
    if (auto val = level0.get(key))     // 1-5msï¼ˆå¯èƒ½å¤šä¸ªæ–‡ä»¶ï¼‰
        return val;
    if (auto val = level1.get(key))     // 5-10ms
        return val;
    // ... level2-6
    return {};
}
// æ€»è€—æ—¶ï¼š1-50msï¼ˆæœ€åæƒ…å†µï¼‰
```

**æ€§èƒ½æ•°æ®**ï¼š
| æ“ä½œ | æœ¬ç³»ç»Ÿ | LevelDB | ä¼˜åŠ¿ |
|------|--------|---------|------|
| **è¯»å–ï¼ˆå­˜åœ¨ï¼‰** | 1-10ms | 1-50ms | **2-5x æ›´å¿«** |
| **è¯»å–ï¼ˆä¸å­˜åœ¨ï¼‰** | < 1Î¼s | 1-10ms | **1000x æ›´å¿«** |
| **é¡ºåºå†™å…¥** | 0.1-1ms | 0.1-1ms | ç›¸å½“ |
| **éšæœºå†™å…¥** | 0.1-1ms | 1-10ms | **æ›´å¿«**ï¼ˆæ— åˆå¹¶ï¼‰ |

**2. æ›´ä½çš„å†™æ”¾å¤§**
```
æœ¬ç³»ç»Ÿå†™æ”¾å¤§ï¼š
å†™å…¥ 1MB æ•°æ®
â”œâ”€ Binlog: 32 å­—èŠ‚è®°å½•
â”œâ”€ æ•°æ®æ–‡ä»¶: 1MB
â””â”€ å‹ç¼©æ—¶é‡å†™: 1MB
æ€»å†™å…¥ï¼š~2MBï¼ˆå†™æ”¾å¤§ = 2ï¼‰

LevelDB å†™æ”¾å¤§ï¼š
å†™å…¥ 1MB æ•°æ®
â”œâ”€ WAL: 1MB
â”œâ”€ MemTable åˆ·ç›˜: 1MBï¼ˆLevel 0ï¼‰
â”œâ”€ Level 0 â†’ 1 åˆå¹¶: 10MBï¼ˆ1:10 æ‰‡å‡ºï¼‰
â”œâ”€ Level 1 â†’ 2 åˆå¹¶: 100MB
â””â”€ ...
æ€»å†™å…¥ï¼š10-50MBï¼ˆå†™æ”¾å¤§ = 10-50ï¼‰
```

**3. å¯åŠ¨é€Ÿåº¦å¿«**
```
æœ¬ç³»ç»Ÿï¼š
å¯åŠ¨æ—¶é—´ = Binlog å¤§å° / ç£ç›˜å¸¦å®½
100ä¸‡æ¡è®°å½• Ã— 32å­—èŠ‚ = 32MB
32MB Ã· 500MB/s = 0.064ç§’ â‰ˆ 60ms âœ…

LevelDBï¼š
å¯åŠ¨æ—¶é—´ = é‡å»º MemTable + åŠ è½½å…ƒæ•°æ®
å¯èƒ½éœ€è¦æ‰«æå¤šä¸ª SSTable æ–‡ä»¶
é€šå¸¸ï¼š100ms - 1s âš ï¸
```

**4. ç®€å•å®ç°ï¼Œæ˜“äºè°ƒè¯•**
```cpp
// æœ¬ç³»ç»Ÿï¼šä»£ç é‡ ~2000 è¡Œ
// æ ¸å¿ƒé€»è¾‘æ¸…æ™°ï¼š
// - HashMap ç´¢å¼•
// - Binlog æ—¥å¿—
// - ç®€å•å‹ç¼©

// LevelDBï¼šä»£ç é‡ ~15000 è¡Œ
// å¤æ‚é€»è¾‘ï¼š
// - MemTableã€Immutable MemTable
// - 7 å±‚ SSTable
// - å¤šç§ Compaction ç­–ç•¥
// - å¸ƒéš†è¿‡æ»¤å™¨ã€å—å‹ç¼©
```

**5. å†…å­˜å ç”¨å¯æ§ä¸”å¯é¢„æµ‹**
```
æœ¬ç³»ç»Ÿï¼ˆ100ä¸‡é”®ï¼‰ï¼š
ç´¢å¼•ï¼š50MBï¼ˆå›ºå®šï¼‰
æ•°æ®ï¼š0MBï¼ˆç£ç›˜ï¼‰
æ€»è®¡ï¼š50MB âœ…

LevelDBï¼ˆ100ä¸‡é”®ï¼‰ï¼š
MemTableï¼š4-8MBï¼ˆå¯é…ç½®ï¼‰
Block Cacheï¼š8-64MBï¼ˆå¯é…ç½®ï¼‰
Table Cacheï¼š10-20MBï¼ˆå…ƒæ•°æ®ï¼‰
Bloom Filterï¼š1-5MB
æ€»è®¡ï¼š~100-200MB âš ï¸ï¼ˆä¸”æ³¢åŠ¨å¤§ï¼‰
```

**6. æ›´é€‚åˆç¼“å­˜åœºæ™¯**
```cpp
// LRU æ¸…ç†ï¼šO(n) éå†ï¼Œç®€å•é«˜æ•ˆ
void cleanLRU() {
    std::vector<Entry*> entries;
    for (auto &[k, e] : _map) {
        entries.push_back(&e);
    }
    std::sort(entries, byTime);  // æŒ‰æ—¶é—´æ’åº
    removeOldest(entries);       // åˆ é™¤æœ€æ—§çš„
}

// LevelDBï¼šéœ€è¦é¢å¤–ç»´æŠ¤æ—¶é—´æˆ³ç´¢å¼•
// æˆ–è€…æ‰«ææ‰€æœ‰ SSTableï¼ˆæ…¢ï¼‰
```

#### LevelDB çš„ä¼˜åŠ¿ âœ…

**1. æ”¯æŒæµ·é‡æ•°æ®**
```
æœ¬ç³»ç»Ÿï¼šé€‚åˆ < 1000ä¸‡é”®ï¼ˆç´¢å¼•å†…å­˜é™åˆ¶ï¼‰
LevelDBï¼šé€‚åˆ > 1äº¿é”®ï¼ˆç£ç›˜ç´¢å¼•ï¼‰

ç¤ºä¾‹ï¼š10äº¿æ¡è®°å½•
æœ¬ç³»ç»Ÿï¼šéœ€è¦ ~60GB å†…å­˜ï¼ˆç´¢å¼•ï¼‰âŒ ä¸å¯è¡Œ
LevelDBï¼šéœ€è¦ ~1GB å†…å­˜ âœ… å®Œå…¨å¯è¡Œ
```

**2. å†™å…¥ååé‡æ›´é«˜ï¼ˆå¤§æ‰¹é‡ï¼‰**
```
æœ¬ç³»ç»Ÿï¼š
æ¯æ¬¡å‹ç¼©éœ€è¦é‡å†™å…¨éƒ¨æ•°æ®
100GB æ•°æ®å‹ç¼© = 100GB å†™å…¥ï¼ˆè€—æ—¶é•¿ï¼‰

LevelDBï¼š
å¢é‡åˆå¹¶ï¼Œåªåˆå¹¶éƒ¨åˆ†æ•°æ®
100GB æ•°æ® + 1GB æ–°æ•°æ® = åˆå¹¶ 10-20GB
```

**3. èŒƒå›´æŸ¥è¯¢æ”¯æŒ**
```cpp
// LevelDBï¼šå¤©ç„¶æ”¯æŒ
auto it = db.NewIterator();
it->Seek("user:1000");
while (it->Valid() && it->key().starts_with("user:")) {
    process(it->value());
    it->Next();
}

// æœ¬ç³»ç»Ÿï¼šä¸æ”¯æŒ âŒ
// HashMap æ— åºï¼Œæ— æ³•èŒƒå›´æŸ¥è¯¢
```

**4. æ›´å¥½çš„å†™å…¥ç¨³å®šæ€§**
```
LevelDBï¼š
åå°åˆå¹¶ï¼Œä¸é˜»å¡å†™å…¥
å†™å…¥å»¶è¿Ÿç¨³å®šï¼š1-5ms

æœ¬ç³»ç»Ÿï¼š
å‹ç¼©æ—¶å¯èƒ½é˜»å¡ï¼ˆå¦‚æœåŒæ­¥å‹ç¼©ï¼‰
å†™å…¥å»¶è¿Ÿæ³¢åŠ¨ï¼š0.1-100ms
```

**5. ç”Ÿäº§çº§å¯é æ€§**
```
LevelDBï¼š
âœ… ä¹…ç»è€ƒéªŒï¼ˆChromeã€Bitcoin ç­‰ï¼‰
âœ… è¯¦ç»†çš„é”™è¯¯å¤„ç†
âœ… å®Œå–„çš„æµ‹è¯•è¦†ç›–
âœ… æ´»è·ƒçš„ç¤¾åŒºæ”¯æŒ

æœ¬ç³»ç»Ÿï¼š
âš ï¸ ç›¸å¯¹ç®€å•
âš ï¸ é€‚åˆç‰¹å®šåœºæ™¯
```

### é€‰æ‹©æŒ‡å—

#### é€‰æ‹©æœ¬ç³»ç»Ÿçš„åœºæ™¯ âœ…

```cpp
// 1. å°åˆ°ä¸­ç­‰è§„æ¨¡ç¼“å­˜ï¼ˆ10ä¸‡-1000ä¸‡æ¡ï¼‰
if (expectedKeys < 10'000'000 && availableRAM > 1GB) {
    return "ä½¿ç”¨æœ¬ç³»ç»Ÿ";
}

// 2. è¯»å¯†é›†å‹åº”ç”¨ï¼ˆè¯»å†™æ¯” > 10:1ï¼‰
if (readOps / writeOps > 10) {
    return "ä½¿ç”¨æœ¬ç³»ç»Ÿï¼ˆè¯»å–æ›´å¿«ï¼‰";
}

// 3. éœ€è¦å¿«é€Ÿå¯åŠ¨
if (startupTimeRequirement < 1_second) {
    return "ä½¿ç”¨æœ¬ç³»ç»Ÿï¼ˆå¯åŠ¨å¿«ï¼‰";
}

// 4. éœ€è¦ LRU æ¸…ç†
if (needAutoEviction) {
    return "ä½¿ç”¨æœ¬ç³»ç»Ÿï¼ˆå†…ç½® LRUï¼‰";
}

// 5. ç®€å•é›†æˆï¼Œå‡å°‘ä¾èµ–
if (preferSimplicity) {
    return "ä½¿ç”¨æœ¬ç³»ç»Ÿï¼ˆä»£ç å°‘ï¼‰";
}
```

**å…¸å‹åœºæ™¯**ï¼š
- âœ… **Telegram/å¾®ä¿¡**ï¼šå›¾ç‰‡/æ–‡ä»¶ç¼“å­˜
- âœ… **æµè§ˆå™¨**ï¼šç½‘é¡µç¼“å­˜ã€Cookie å­˜å‚¨
- âœ… **IDE**ï¼šç¬¦å·ç´¢å¼•ã€æ„å»ºç¼“å­˜
- âœ… **æ¸¸æˆ**ï¼šèµ„æºç¼“å­˜ã€å­˜æ¡£æ•°æ®
- âœ… **ç§»åŠ¨åº”ç”¨**ï¼šç¦»çº¿æ•°æ®ã€é…ç½®ç¼“å­˜

#### é€‰æ‹© LevelDB çš„åœºæ™¯ âœ…

```cpp
// 1. æµ·é‡æ•°æ®ï¼ˆ> 1000ä¸‡æ¡ï¼‰
if (expectedKeys > 10'000'000) {
    return "ä½¿ç”¨ LevelDBï¼ˆå†…å­˜å‹å¥½ï¼‰";
}

// 2. å†™å¯†é›†å‹åº”ç”¨
if (writeOps / readOps > 1) {
    return "ä½¿ç”¨ LevelDBï¼ˆå†™å…¥ååé«˜ï¼‰";
}

// 3. éœ€è¦èŒƒå›´æŸ¥è¯¢
if (needRangeQueries) {
    return "ä½¿ç”¨ LevelDBï¼ˆæœ‰åºå­˜å‚¨ï¼‰";
}

// 4. æ•°æ®æŒç»­å¢é•¿
if (dataGrowthIsUnbounded) {
    return "ä½¿ç”¨ LevelDBï¼ˆå¯æ‰©å±•ï¼‰";
}

// 5. éœ€è¦ç”Ÿäº§çº§å¯é æ€§
if (isCriticalData) {
    return "ä½¿ç”¨ LevelDBï¼ˆä¹…ç»è€ƒéªŒï¼‰";
}
```

**å…¸å‹åœºæ™¯**ï¼š
- âœ… **åŒºå—é“¾**ï¼šäº¤æ˜“è®°å½•ã€åŒºå—æ•°æ®
- âœ… **æ—¶åºæ•°æ®åº“**ï¼šInfluxDBã€Prometheus
- âœ… **æ¶ˆæ¯é˜Ÿåˆ—**ï¼šRocketMQã€Kafkaï¼ˆéƒ¨åˆ†ï¼‰
- âœ… **æœç´¢å¼•æ“**ï¼šå€’æ’ç´¢å¼•
- âœ… **å¤§æ•°æ®å¤„ç†**ï¼šBigtableã€HBase

### æ··åˆæ–¹æ¡ˆ

**ä½•æ—¶è€ƒè™‘æ··åˆï¼Ÿ**

```cpp
class HybridCache {
    // çƒ­æ•°æ®ï¼šæœ¬ç³»ç»Ÿï¼ˆå¿«é€Ÿç¼“å­˜ï¼‰
    DesktopAppCache _hotCache;
    
    // å†·æ•°æ®ï¼šLevelDBï¼ˆæŒä¹…åŒ–å­˜å‚¨ï¼‰
    leveldb::DB* _coldStorage;
    
    QByteArray get(Key key) {
        // 1. å…ˆæŸ¥çƒ­ç¼“å­˜
        if (auto val = _hotCache.get(key)) {
            return val;
        }
        
        // 2. å†æŸ¥å†·å­˜å‚¨
        std::string value;
        auto status = _coldStorage->Get(
            leveldb::ReadOptions(), 
            encodeKey(key), 
            &value
        );
        
        if (status.ok()) {
            // 3. æå‡åˆ°çƒ­ç¼“å­˜
            _hotCache.put(key, QByteArray(value));
            return QByteArray(value);
        }
        
        return {};
    }
};
```

**é€‚ç”¨åœºæ™¯**ï¼š
- æ•°æ®åˆ†å±‚ï¼šçƒ­æ•°æ®ï¼ˆæœ¬ç³»ç»Ÿï¼‰+ å†·æ•°æ®ï¼ˆLevelDBï¼‰
- ç¼“å­˜ + æŒä¹…åŒ–ï¼šä¸´æ—¶ç¼“å­˜ï¼ˆæœ¬ç³»ç»Ÿï¼‰+ é•¿æœŸå­˜å‚¨ï¼ˆLevelDBï¼‰
- è¯»å†™åˆ†ç¦»ï¼šè¯»ç¼“å­˜ï¼ˆæœ¬ç³»ç»Ÿï¼‰+ å†™å­˜å‚¨ï¼ˆLevelDBï¼‰

### æ€§èƒ½åŸºå‡†æµ‹è¯•

```
æµ‹è¯•ç¯å¢ƒï¼š
- CPU: Intel i7-12700
- RAM: 32GB DDR4
- SSD: Samsung 980 Pro (7000 MB/s)
- æ•°æ®é›†: 100ä¸‡æ¡è®°å½•ï¼Œæ¯æ¡ 1KB

è¯»å–æ€§èƒ½ï¼ˆéšæœºè¯»ï¼‰ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      æ“ä½œ          â”‚   æœ¬ç³»ç»Ÿ     â”‚   LevelDB    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ é”®å­˜åœ¨ï¼ˆå‘½ä¸­ï¼‰      â”‚   1.2 ms     â”‚   3.5 ms     â”‚
â”‚ é”®ä¸å­˜åœ¨ï¼ˆæœªå‘½ä¸­ï¼‰  â”‚   0.0008 ms  â”‚   2.1 ms     â”‚
â”‚ é¡ºåºè¯»å–           â”‚   0.8 ms     â”‚   0.9 ms     â”‚
â”‚ QPSï¼ˆå•çº¿ç¨‹ï¼‰       â”‚   ~800       â”‚   ~280       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å†™å…¥æ€§èƒ½ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      æ“ä½œ          â”‚   æœ¬ç³»ç»Ÿ     â”‚   LevelDB    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å•æ¡å†™å…¥           â”‚   0.3 ms     â”‚   1.2 ms     â”‚
â”‚ æ‰¹é‡å†™å…¥ï¼ˆ1000æ¡ï¼‰ â”‚   150 ms     â”‚   180 ms     â”‚
â”‚ QPSï¼ˆå•çº¿ç¨‹ï¼‰       â”‚   ~3300      â”‚   ~800       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å†…å­˜å ç”¨ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      æŒ‡æ ‡          â”‚   æœ¬ç³»ç»Ÿ     â”‚   LevelDB    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ç´¢å¼•å†…å­˜           â”‚   60 MB      â”‚   120 MB     â”‚
â”‚ å³°å€¼å†…å­˜           â”‚   60 MB      â”‚   180 MB     â”‚
â”‚ å¯åŠ¨æ—¶é—´           â”‚   80 ms      â”‚   350 ms     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ç£ç›˜å ç”¨ï¼š
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚      æŒ‡æ ‡          â”‚   æœ¬ç³»ç»Ÿ     â”‚   LevelDB    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ•°æ®æ–‡ä»¶           â”‚   1000 MB    â”‚   1000 MB    â”‚
â”‚ Binlog/WAL         â”‚   32 MB      â”‚   0 MB       â”‚
â”‚ å…ƒæ•°æ®             â”‚   < 1 MB     â”‚   50 MB      â”‚
â”‚ æ€»è®¡               â”‚   ~1033 MB   â”‚   ~1050 MB   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ€»ç»“

**æœ¬ç³»ç»Ÿçš„æ ¸å¿ƒä¼˜åŠ¿**ï¼š
1. ğŸš€ **è¯»å–é€Ÿåº¦å¿«** - å…¨å†…å­˜ç´¢å¼•ï¼ŒO(1) æŸ¥æ‰¾
2. ğŸ’¾ **å†…å­˜å ç”¨ä½** - åªå­˜å…ƒæ•°æ®ï¼Œæ•°æ®åœ¨ç£ç›˜
3. âš¡ **å¯åŠ¨é€Ÿåº¦å¿«** - Binlog é‡æ”¾ï¼Œç™¾æ¯«ç§’çº§
4. ğŸ¯ **å†™å…¥ç®€å•é«˜æ•ˆ** - æ— å¤æ‚åˆå¹¶ï¼Œä½å†™æ”¾å¤§
5. ğŸ§¹ **LRU æ¸…ç†æ–¹ä¾¿** - å¯éå†æ‰€æœ‰é”®ï¼Œè½»æ¾å®ç°ç¼“å­˜ç­–ç•¥
6. ğŸ”§ **å®ç°ç®€å•** - ä»£ç å°‘ï¼Œæ˜“ç†è§£ï¼Œæ˜“è°ƒè¯•
7. ğŸ“ **å ç”¨å¯é¢„æµ‹** - å†…å­˜ = é”®æ•°é‡ Ã— 64Bï¼Œå¯ç²¾ç¡®ä¼°ç®—

**é€‚ç”¨åœºæ™¯æ€»ç»“**ï¼š
- âœ… **10ä¸‡-1000ä¸‡**æ¡è®°å½•çš„ç¼“å­˜ç³»ç»Ÿ
- âœ… **è¯»å¯†é›†å‹**åº”ç”¨ï¼ˆè¯»å†™æ¯” > 5:1ï¼‰
- âœ… éœ€è¦**å¿«é€Ÿå¯åŠ¨**ï¼ˆ< 1ç§’ï¼‰
- âœ… éœ€è¦**è‡ªåŠ¨æ¸…ç†**ï¼ˆLRUã€TTLï¼‰
- âœ… **æ¡Œé¢/ç§»åŠ¨åº”ç”¨**çš„æœ¬åœ°ç¼“å­˜
- âŒ **ä¸é€‚åˆ**ï¼šæµ·é‡æ•°æ®ï¼ˆ> 1000ä¸‡ï¼‰ã€èŒƒå›´æŸ¥è¯¢ã€å†™å¯†é›†å‹

---

## æ€»ç»“

### æ ¸å¿ƒè¦ç‚¹

1. **å´©æºƒä¸€è‡´æ€§**ï¼šä½¿ç”¨ WAL ç¡®ä¿æ•°æ®ä¸ä¸¢å¤±
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡æ“ä½œã€ç¼“å­˜ã€é¢„åˆ†é…
3. **ç©ºé—´ç®¡ç†**ï¼šLRU æ¸…ç†ã€æ—¥å¿—å‹ç¼©
4. **å¯é æ€§**ï¼šæ ¡éªŒå’Œã€é”™è¯¯å¤„ç†ã€å®šæœŸéªŒè¯
5. **çº¿ç¨‹å®‰å…¨**ï¼šå•çº¿ç¨‹æ¨¡å‹æˆ–ç»†ç²’åº¦é”

### è®¾è®¡å†³ç­–æ ‘

```
éœ€è¦æŒä¹…åŒ–ï¼Ÿ
â”œâ”€ æ˜¯ â†’ éœ€è¦å´©æºƒæ¢å¤ï¼Ÿ
â”‚   â”œâ”€ æ˜¯ â†’ ä½¿ç”¨ WAL
â”‚   â””â”€ å¦ â†’ å®šæœŸå¿«ç…§
â””â”€ å¦ â†’ çº¯å†…å­˜ç¼“å­˜

æ•°æ®é‡çº§ï¼Ÿï¼ˆåŸºäºå…¨å†…å­˜ç´¢å¼•ï¼‰
â”œâ”€ < 10 ä¸‡é”® â†’ å…¨å†…å­˜ç´¢å¼•ï¼ˆ< 5 MBï¼‰
â”‚   â””â”€ é€‚åˆï¼šç§»åŠ¨åº”ç”¨ã€å°å‹æ¡Œé¢åº”ç”¨
â”œâ”€ 10-100 ä¸‡é”® â†’ å…¨å†…å­˜ç´¢å¼•ï¼ˆ5-60 MBï¼‰
â”‚   â””â”€ é€‚åˆï¼šæ¡Œé¢åº”ç”¨ç¼“å­˜ã€ä¸­å‹æœåŠ¡
â”‚   â””â”€ æœ¬ç³»ç»Ÿçš„æœ€ä½³èŒƒå›´ â­
â”œâ”€ 100-1000 ä¸‡é”® â†’ å…¨å†…å­˜ç´¢å¼•ï¼ˆ60-600 MBï¼‰
â”‚   â””â”€ é€‚åˆï¼šå¤§å‹æ¡Œé¢åº”ç”¨ï¼ˆå†…å­˜å……è¶³ï¼‰
â”‚   â””â”€ éœ€è¦ä¼˜åŒ–ï¼šç´§å‡‘ç»“æ„ã€å†…å­˜æ± 
â”œâ”€ 1000 ä¸‡-1 äº¿é”® â†’ æ··åˆç´¢å¼•ï¼ˆçƒ­å†…å­˜ + å†·ç£ç›˜ï¼‰
â”‚   â””â”€ éœ€è¦ï¼šLSM Tree æˆ– B+ Tree
â”‚   â””â”€ ç¤ºä¾‹ï¼šLevelDBã€RocksDB
â””â”€ > 1 äº¿é”® â†’ çº¯ç£ç›˜ç´¢å¼• + å¸ƒéš†è¿‡æ»¤å™¨
    â””â”€ éœ€è¦ï¼šåˆ†å±‚ç´¢å¼•ã€åˆ†å¸ƒå¼æ–¹æ¡ˆ
    â””â”€ ç¤ºä¾‹ï¼šHBaseã€Cassandra

æ€§èƒ½è¦æ±‚ï¼Ÿ
â”œâ”€ é«˜ååï¼ˆ> 10K ops/sï¼‰
â”‚   â””â”€ æ‰¹é‡æ“ä½œ + å¼‚æ­¥ IO + å…¨å†…å­˜ç´¢å¼•
â”œâ”€ ä½å»¶è¿Ÿï¼ˆ< 1msï¼‰
â”‚   â””â”€ å…¨å†…å­˜ç´¢å¼• + L1/L2 ç¼“å­˜ + é¢„åŠ è½½
â””â”€ å¹³è¡¡
    â””â”€ å»¶è¿Ÿæ‰¹é‡ + éƒ¨åˆ†å†…å­˜ç¼“å­˜ï¼ˆæœ¬ç³»ç»Ÿï¼‰

å†…å­˜é™åˆ¶ï¼Ÿ
â”œâ”€ å……è¶³ï¼ˆ> 2GB å¯ç”¨ï¼‰
â”‚   â””â”€ å…¨å†…å­˜ç´¢å¼•ï¼ˆæ”¯æŒç™¾ä¸‡çº§ï¼‰
â”œâ”€ æœ‰é™ï¼ˆ256MB - 2GBï¼‰
â”‚   â””â”€ å…¨å†…å­˜ç´¢å¼•ï¼ˆé™åˆ¶åœ¨ 10-100 ä¸‡é”®ï¼‰
â”‚   â””â”€ ä½¿ç”¨ç´§å‡‘ç»“æ„ä¼˜åŒ–
â””â”€ ç´§å¼ ï¼ˆ< 256MBï¼‰
    â””â”€ æ··åˆç´¢å¼•æˆ–çº¯ç£ç›˜ç´¢å¼•
    â””â”€ Bloom Filter + æŒ‰éœ€åŠ è½½

å¯é æ€§è¦æ±‚ï¼Ÿ
â”œâ”€ å…³é”®æ•°æ® â†’ åŒæ­¥åˆ·ç›˜ã€æ ¡éªŒå’Œã€å¤‡ä»½
â”œâ”€ æ™®é€šæ•°æ® â†’ å¼‚æ­¥åˆ·ç›˜ã€åŸºæœ¬æ ¡éªŒï¼ˆæœ¬ç³»ç»Ÿï¼‰
â””â”€ ä¸´æ—¶æ•°æ® â†’ æ— éœ€æŒä¹…åŒ–
```

### æœ¬ç³»ç»Ÿçš„å®šä½æ€»ç»“

**Desktop App Toolkit Cache ç³»ç»Ÿ**æ˜¯ä¸€ä¸ªï¼š

âœ… **ä¸­å°è§„æ¨¡**åµŒå…¥å¼ KV å­˜å‚¨
- æœ€ä½³æ•°æ®é‡ï¼š**10 ä¸‡ - 100 ä¸‡æ¡è®°å½•**
- å¯æ¥å—èŒƒå›´ï¼š**< 1000 ä¸‡æ¡è®°å½•**ï¼ˆå†…å­˜å……è¶³æ—¶ï¼‰

âœ… **å…¨å†…å­˜ç´¢å¼•** + ç£ç›˜æ•°æ®
- ç´¢å¼•ï¼šO(1) æŸ¥æ‰¾ï¼Œå¾®ç§’çº§å“åº”
- æ•°æ®ï¼šç£ç›˜å­˜å‚¨ï¼ŒèŠ‚çœå†…å­˜
- å¯åŠ¨ï¼š1-2 ç§’ï¼ˆç™¾ä¸‡çº§ï¼‰

âœ… **å…¸å‹åº”ç”¨åœºæ™¯**
- Telegram Desktop å›¾ç‰‡ç¼“å­˜
- æµè§ˆå™¨ç½‘é¡µç¼“å­˜
- åº”ç”¨é…ç½®/èµ„æºç¼“å­˜
- èŠå¤©è®°å½•ç¦»çº¿å­˜å‚¨

âŒ **ä¸é€‚åˆ**
- æ•°åäº¿çº§å¤§æ•°æ®ï¼ˆç”¨ LevelDBï¼‰
- åˆ†å¸ƒå¼ç¼“å­˜ï¼ˆç”¨ Redisï¼‰
- å†…å­˜æå°è®¾å¤‡ï¼ˆ< 64MB RAMï¼‰

### è¿›é˜¶é˜…è¯»

- **LSM Tree**ï¼šé€‚åˆå†™å¯†é›†åœºæ™¯ï¼ˆLevelDBã€RocksDBï¼‰
- **B+ Tree**ï¼šé€‚åˆè¯»å¯†é›†åœºæ™¯ï¼ˆSQLiteã€BerkeleyDBï¼‰
- **MVCC**ï¼šå¤šç‰ˆæœ¬å¹¶å‘æ§åˆ¶ï¼ˆPostgreSQLï¼‰
- **Raft/Paxos**ï¼šåˆ†å¸ƒå¼ä¸€è‡´æ€§ï¼ˆetcdã€Consulï¼‰

---

## é™„å½•ï¼šå®Œæ•´ä»£ç ç¤ºä¾‹

è¯¦è§é¡¹ç›®æºä»£ç ï¼š
- `storage_cache_types.h/cpp` - æ•°æ®ç»“æ„å®šä¹‰
- `storage_cache_database.h/cpp` - å…¬å…± API
- `storage_cache_database_object.h/cpp` - æ ¸å¿ƒå¼•æ“
- `storage_cache_binlog_reader.h/cpp` - æ—¥å¿—è¯»å–
- `storage_cache_cleaner.h/cpp` - ç©ºé—´æ¸…ç†
- `storage_cache_compactor.h/cpp` - æ—¥å¿—å‹ç¼©
